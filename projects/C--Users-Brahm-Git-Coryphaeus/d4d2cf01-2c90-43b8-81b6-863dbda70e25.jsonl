{"type":"summary","summary":"Firebase Storage Structure Optimization","leafUuid":"9f945053-6614-43e8-b238-1bbbefb62b59"}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":"Let's discuss:  docs\\firebase-storage-plan.md\\\n\\\nExplain to me how attempted uploads will be logged?"},"uuid":"e86f87d4-a4b9-4beb-b67d-63016f1382c6","timestamp":"2025-08-20T16:28:42.291Z"}
{"parentUuid":"e86f87d4-a4b9-4beb-b67d-63016f1382c6","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01UF1QWixnRwi6BRymR4RqDG","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_012ng55Kgoe5VhoA9akVVKoG","name":"Read","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":8673,"cache_read_input_tokens":11616,"cache_creation":{"ephemeral_5m_input_tokens":8673,"ephemeral_1h_input_tokens":0},"output_tokens":76,"service_tier":"standard"}},"requestId":"req_011CSKH4UENuhM1w8pHjQL6M","type":"assistant","uuid":"f51f804a-c25b-4b6e-b13d-7f9d0d5535ff","timestamp":"2025-08-20T16:28:45.619Z"}
{"parentUuid":"f51f804a-c25b-4b6e-b13d-7f9d0d5535ff","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012ng55Kgoe5VhoA9akVVKoG","type":"tool_result","content":"     1→# Simplified Firebase Storage Plan (KISS Edition)\n     2→\n     3→## Overview\n     4→\n     5→**Core Simplification**: ALL files go through matters. No exceptions.\n     6→\n     7→This eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n     8→\n     9→**Key Principles:**\n    10→- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n    11→- Every upload attempt is logged (successful or duplicate)\n    12→- Simple, consistent security rules\n    13→- Clear audit trail for compliance\n    14→- Handles multi-client matters and pre-matter intake documents\n    15→\n    16→## Naming Conventions\n    17→\n    18→To keep things organized and queryable:\n    19→- **Team general**: `matter-general`\n    20→- **Client intake**: `matter-client-{clientId}-general`  \n    21→- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n    22→- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n    23→\n    24→## Storage Structure (Simplified)\n    25→\n    26→```\n    27→Firebase Storage Root\n    28→└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n    29→```\n    30→\n    31→That's it. One pattern. Every file follows this structure.\n    32→\n    33→### Special System Matters\n    34→\n    35→Each team automatically gets these special matters:\n    36→- `matter-general` - Team resources, templates, non-client documents\n    37→- `matter-archive` - Archived/inactive documents\n    38→\n    39→### Client Intake Matters\n    40→\n    41→Each client gets a special intake matter for pre-matter documents:\n    42→- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n    43→\n    44→Example: Client ABC Corp would have:\n    45→- `matter-client-abc-general` - Initial consultations, general corporate docs\n    46→- `matter-abc-001` - Specific matter #1 (contract review)\n    47→- `matter-abc-002` - Specific matter #2 (litigation)\n    48→\n    49→### Multi-Client Matters\n    50→\n    51→Matters can have multiple clients (stored in Firestore):\n    52→```javascript\n    53→// In Firestore: /teams/{teamId}/matters/{matterId}\n    54→{\n    55→  matterId: 'matter-smith-estate-001',\n    56→  title: 'Smith Estate Planning',\n    57→  clients: [\n    58→    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    59→    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n    60→  ],\n    61→  status: 'active'\n    62→}\n    63→\n    64→## File Storage Implementation\n    65→\n    66→### 1. Upload Service (Simple & Complete)\n    67→\n    68→```javascript\n    69→class StorageService {\n    70→  async uploadFile(file, teamId, matterId, metadata = {}) {\n    71→    // 1. Calculate hash\n    72→    const fileHash = await this.calculateSHA256(file)\n    73→    const extension = file.name.split('.').pop().toLowerCase()\n    74→    const fileName = `${fileHash}.${extension}`\n    75→    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    76→    \n    77→    // 2. Create upload attempt record (ALWAYS, even for duplicates)\n    78→    const attemptId = await this.logUploadAttempt({\n    79→      teamId,\n    80→      matterId,\n    81→      fileName: file.name,\n    82→      fileHash,\n    83→      storagePath,\n    84→      fileSize: file.size,\n    85→      mimeType: file.type,\n    86→      metadata,\n    87→      uploadedBy: auth.currentUser.uid,\n    88→      attemptedAt: new Date()\n    89→    })\n    90→    \n    91→    // 3. Check if file exists\n    92→    const fileRef = storage.ref(storagePath)\n    93→    const exists = await this.checkFileExists(fileRef)\n    94→    \n    95→    if (exists) {\n    96→      // 4a. File exists - just create a reference\n    97→      await this.createFileReference({\n    98→        ...metadata,\n    99→        fileHash,\n   100→        storagePath,\n   101→        isDuplicate: true,\n   102→        originalUploadAttemptId: attemptId\n   103→      })\n   104→      \n   105→      return { \n   106→        success: true, \n   107→        isDuplicate: true,\n   108→        storagePath,\n   109→        attemptId\n   110→      }\n   111→    }\n   112→    \n   113→    // 4b. New file - upload it\n   114→    await fileRef.put(file)\n   115→    \n   116→    // 5. Create file reference\n   117→    const docId = await this.createFileReference({\n   118→      ...metadata,\n   119→      fileHash,\n   120→      storagePath,\n   121→      isDuplicate: false,\n   122→      originalUploadAttemptId: attemptId\n   123→    })\n   124→    \n   125→    return { \n   126→      success: true, \n   127→      isDuplicate: false,\n   128→      storagePath,\n   129→      documentId: docId,\n   130→      attemptId\n   131→    }\n   132→  }\n   133→  \n   134→  async calculateSHA256(file) {\n   135→    const buffer = await file.arrayBuffer()\n   136→    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n   137→    const hashArray = Array.from(new Uint8Array(hashBuffer))\n   138→    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n   139→  }\n   140→}\n   141→```\n   142→\n   143→### 2. Firestore Collections (Simplified)\n   144→\n   145→#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n   146→```javascript\n   147→{\n   148→  // Core identifiers\n   149→  fileHash: 'abc123...',           // SHA-256 hash\n   150→  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n   151→  \n   152→  // User-friendly info\n   153→  displayName: 'Contract_2024.pdf', // What users see\n   154→  originalFileName: 'Contract ABC Corp.pdf',\n   155→  \n   156→  // Organization\n   157→  matterId: 'matter-123',\n   158→  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n   159→  \n   160→  // Metadata\n   161→  fileSize: 1048576,\n   162→  mimeType: 'application/pdf',\n   163→  uploadedBy: 'user-123',\n   164→  uploadedAt: Timestamp,\n   165→  \n   166→  // Simple categorization\n   167→  tags: ['contract', 'draft'],     // Simple array of tags\n   168→  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n   169→}\n   170→```\n   171→\n   172→#### Upload Attempts Log: `/teams/{teamId}/upload_attempts/{attemptId}`\n   173→```javascript\n   174→{\n   175→  // What was attempted\n   176→  fileName: 'Contract ABC Corp.pdf',\n   177→  fileHash: 'abc123...',\n   178→  fileSize: 1048576,\n   179→  mimeType: 'application/pdf',\n   180→  \n   181→  // Where it was going\n   182→  matterId: 'matter-123',\n   183→  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n   184→  \n   185→  // Who and when\n   186→  uploadedBy: 'user-123',\n   187→  attemptedAt: Timestamp,\n   188→  \n   189→  // Result\n   190→  wasSuccessful: true,              // false if error\n   191→  wasDuplicate: false,              // true if file already existed\n   192→  error: null,                      // Error message if failed\n   193→  \n   194→  // User metadata from upload\n   195→  userMetadata: {\n   196→    notes: 'Initial draft version'\n   197→  }\n   198→}\n   199→```\n   200→\n   201→## Security Rules (Dead Simple)\n   202→\n   203→```javascript\n   204→rules_version = '2';\n   205→service firebase.storage {\n   206→  match /b/{bucket}/o {\n   207→    // One rule: Team members can access their team's files\n   208→    match /teams/{teamId}/matters/{matterId}/{fileName} {\n   209→      allow read, write: if request.auth != null && \n   210→                           request.auth.token.teamId == teamId;\n   211→    }\n   212→  }\n   213→}\n   214→```\n   215→\n   216→## Firestore Security Rules\n   217→\n   218→```javascript\n   219→rules_version = '2';\n   220→service cloud.firestore {\n   221→  match /databases/{database}/documents {\n   222→    // Team members can read all team documents and upload attempts\n   223→    match /teams/{teamId}/documents/{doc} {\n   224→      allow read: if request.auth != null && \n   225→                     request.auth.token.teamId == teamId;\n   226→      allow create: if request.auth != null && \n   227→                       request.auth.token.teamId == teamId;\n   228→      allow update, delete: if false;  // Documents are immutable\n   229→    }\n   230→    \n   231→    match /teams/{teamId}/upload_attempts/{attempt} {\n   232→      allow read: if request.auth != null && \n   233→                     request.auth.token.teamId == teamId;\n   234→      allow create: if request.auth != null && \n   235→                       request.auth.token.teamId == teamId;\n   236→      allow update, delete: if false;  // Attempts are immutable\n   237→    }\n   238→  }\n   239→}\n   240→```\n   241→\n   242→## Client Isolation Strategy\n   243→\n   244→### Matter-Based Isolation\n   245→Since ALL files go through matters, client isolation is automatic:\n   246→- Client A intake → `matter-client-A-general`\n   247→- Client B intake → `matter-client-B-general`\n   248→- Joint clients → `matter-smith-estate-001` (both clients listed)\n   249→- Team files → `matter-general`\n   250→\n   251→### Multi-Client Considerations\n   252→When matters have multiple clients (e.g., husband & wife):\n   253→1. **Documents are associated with the matter**, not individual clients\n   254→2. **All clients of a matter can access that matter's documents**\n   255→3. **Client intake folders remain separate** until formally combined in a matter\n   256→\n   257→Example workflow:\n   258→```javascript\n   259→// John Smith uploads documents during initial consultation\n   260→uploadFile(file, teamId, 'matter-client-john-general')\n   261→\n   262→// Jane Smith uploads documents during her consultation  \n   263→uploadFile(file, teamId, 'matter-client-jane-general')\n   264→\n   265→// Lawyer opens joint matter for estate planning\n   266→createMatter('matter-smith-estate-001', {\n   267→  clients: ['client-john-smith', 'client-jane-smith']\n   268→})\n   269→\n   270→// New documents go to the joint matter\n   271→uploadFile(file, teamId, 'matter-smith-estate-001')\n   272→\n   273→// Optional: Associate intake documents with new matter\n   274→associateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n   275→```\n   276→\n   277→### Security Benefits\n   278→1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n   279→2. **Clear boundaries**: Each matter is a clear security boundary\n   280→3. **No accidents**: Can't accidentally mix different clients' matters\n   281→4. **Audit trail**: Document associations are tracked\n   282→```\n   283→\n   284→## Tracking & Audit Trail\n   285→\n   286→### Every Upload Attempt is Logged\n   287→```javascript\n   288→// Example: User uploads same file 3 times to different matters\n   289→// Result: 1 file in storage, 3 upload_attempts records\n   290→\n   291→// Attempt 1: New file to matter-123\n   292→{\n   293→  attemptId: 'attempt-001',\n   294→  fileName: 'Contract.pdf',\n   295→  fileHash: 'abc123',\n   296→  matterId: 'matter-123',\n   297→  wasDuplicate: false,  // First upload\n   298→  wasSuccessful: true\n   299→}\n   300→\n   301→// Attempt 2: Same file to matter-456\n   302→{\n   303→  attemptId: 'attempt-002',\n   304→  fileName: 'Contract_Final.pdf',  // Different name, same content\n   305→  fileHash: 'abc123',              // Same hash!\n   306→  matterId: 'matter-456',\n   307→  wasDuplicate: true,               // Detected duplicate\n   308→  wasSuccessful: true\n   309→}\n   310→\n   311→// Attempt 3: Upload failed (network error)\n   312→{\n   313→  attemptId: 'attempt-003',\n   314→  fileName: 'Contract.pdf',\n   315→  fileHash: 'abc123',\n   316→  matterId: 'matter-789',\n   317→  wasDuplicate: true,\n   318→  wasSuccessful: false,\n   319→  error: 'Network timeout'\n   320→}\n   321→```\n   322→\n   323→### Useful Queries\n   324→\n   325→```javascript\n   326→// Find all documents for a specific client (across all matters)\n   327→const clientDocs = await db\n   328→  .collection('teams').doc(teamId)\n   329→  .collection('documents')\n   330→  .where('clientIds', 'array-contains', clientId)\n   331→  .orderBy('uploadedAt', 'desc')\n   332→  .get()\n   333→\n   334→// Find intake documents for a client (pre-matter)\n   335→const intakeDocs = await db\n   336→  .collection('teams').doc(teamId)\n   337→  .collection('documents')\n   338→  .where('matterId', '==', `matter-client-${clientId}-general`)\n   339→  .orderBy('uploadedAt', 'desc')\n   340→  .get()\n   341→\n   342→// Find all uploads by a user\n   343→const userUploads = await db\n   344→  .collection('teams').doc(teamId)\n   345→  .collection('upload_attempts')\n   346→  .where('uploadedBy', '==', userId)\n   347→  .orderBy('attemptedAt', 'desc')\n   348→  .get()\n   349→\n   350→// Find duplicate upload attempts\n   351→const duplicates = await db\n   352→  .collection('teams').doc(teamId)\n   353→  .collection('upload_attempts')\n   354→  .where('wasDuplicate', '==', true)\n   355→  .get()\n   356→\n   357→// Get upload history for a specific file hash\n   358→const fileHistory = await db\n   359→  .collection('teams').doc(teamId)\n   360→  .collection('upload_attempts')\n   361→  .where('fileHash', '==', fileHash)\n   362→  .orderBy('attemptedAt', 'desc')\n   363→  .get()\n   364→\n   365→// Find all documents for a multi-client matter\n   366→const matterDocs = await db\n   367→  .collection('teams').doc(teamId)\n   368→  .collection('documents')\n   369→  .where('matterId', '==', matterId)\n   370→  .orderBy('uploadedAt', 'desc')\n   371→  .get()\n   372→```\n   373→\n   374→## Implementation Phases\n   375→\n   376→### Phase 1: Core Upload (Week 1)\n   377→- [ ] SHA-256 calculation\n   378→- [ ] Basic upload to matter folders\n   379→- [ ] Document reference creation\n   380→- [ ] Upload attempt logging\n   381→- [ ] Create system matters (general, client-general)\n   382→\n   383→### Phase 2: Search & Retrieval (Week 2)\n   384→- [ ] Document search by name/tags\n   385→- [ ] Client document aggregation across matters\n   386→- [ ] Download functionality\n   387→- [ ] Upload history viewing\n   388→\n   389→### Phase 3: Nice-to-haves (If needed)\n   390→- [ ] Bulk upload\n   391→- [ ] File preview\n   392→- [ ] Document association between matters\n   393→- [ ] Intake-to-matter workflow automation\n   394→\n   395→## Practical Workflows\n   396→\n   397→### New Client Consultation Flow\n   398→```javascript\n   399→// 1. Client calls for consultation\n   400→const clientId = await createClient({\n   401→  name: 'John Smith',\n   402→  email: 'john@example.com'\n   403→})\n   404→\n   405→// 2. System auto-creates intake matter\n   406→const intakeMatterId = `matter-client-${clientId}-general`\n   407→\n   408→// 3. Upload consultation documents\n   409→await uploadFile(consulationNotes, teamId, intakeMatterId)\n   410→await uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n   411→\n   412→// 4. If client engages firm, create formal matter\n   413→const formalMatterId = await createMatter({\n   414→  id: 'matter-smith-divorce-001',\n   415→  clients: [clientId],\n   416→  type: 'divorce'\n   417→})\n   418→\n   419→// 5. New documents go to formal matter\n   420→await uploadFile(retainerAgreement, teamId, formalMatterId)\n   421→\n   422→// 6. Optionally associate intake docs with formal matter\n   423→// (creates references, doesn't move files)\n   424→```\n   425→\n   426→### Joint Client Matter Flow\n   427→```javascript\n   428→// 1. Create both clients\n   429→const husbandId = await createClient({ name: 'John Smith' })\n   430→const wifeId = await createClient({ name: 'Jane Smith' })\n   431→\n   432→// 2. Each may have individual intake documents\n   433→await uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\n   434→await uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n   435→\n   436→// 3. Create joint matter\n   437→const jointMatterId = await createMatter({\n   438→  id: 'matter-smith-estate-001',\n   439→  clients: [husbandId, wifeId],\n   440→  type: 'estate-planning'\n   441→})\n   442→\n   443→// 4. Joint documents go to joint matter\n   444→await uploadFile(jointAssets, teamId, jointMatterId)\n   445→```\n   446→\n   447→## Migration Path for Existing Files\n   448→\n   449→If you already have files in Firebase Storage:\n   450→\n   451→```javascript\n   452→async function migrateToMatterStructure() {\n   453→  // 1. Create system matters\n   454→  await createSystemMatters(teamId)\n   455→  \n   456→  // 2. Create client intake matters for existing clients\n   457→  const clients = await getExistingClients()\n   458→  for (const client of clients) {\n   459→    await createMatter({\n   460→      id: `matter-client-${client.id}-general`,\n   461→      name: `${client.name} - Intake Documents`,\n   462→      isSystemMatter: true,\n   463→      clients: [client.id]\n   464→    })\n   465→  }\n   466→  \n   467→  // 3. Map existing files to appropriate matters\n   468→  // Team files → matter-general\n   469→  // Client files without matter → matter-client-{id}-general\n   470→  // Client files with matter → keep in existing matter\n   471→  \n   472→  // 4. Update Firestore document references\n   473→  // 5. Clean up old structure (after verification)\n   474→}\n   475→\n   476→async function createSystemMatters(teamId) {\n   477→  // Create team general matter\n   478→  await createMatter({\n   479→    id: 'matter-general',\n   480→    name: 'General Team Documents',\n   481→    isSystemMatter: true,\n   482→    clients: []\n   483→  })\n   484→  \n   485→  // Create archive matter\n   486→  await createMatter({\n   487→    id: 'matter-archive',\n   488→    name: 'Archived Documents',\n   489→    isSystemMatter: true,\n   490→    clients: []\n   491→  })\n   492→}\n   493→```\n   494→\n   495→## Benefits of This Simplified Approach\n   496→\n   497→1. **One Pattern**: Developers only learn one file path pattern\n   498→2. **Consistent Security**: Same rules apply to all files\n   499→3. **Natural Isolation**: Matter-based structure naturally isolates clients\n   500→4. **Complete Audit Trail**: Every upload attempt is logged\n   501→5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n   502→6. **Simple Queries**: Flat structure makes queries straightforward\n   503→7. **Future-Proof**: Can add features without changing core structure\n   504→\n   505→## What We Removed (YAGNI)\n   506→\n   507→- ❌ Complex three-tier structure (system/team/matter)\n   508→- ❌ Multiple storage patterns to remember\n   509→- ❌ Versioning system (add later if needed)\n   510→- ❌ Complex metadata (keep it flat)\n   511→- ❌ System files folder (use matter-general instead)\n   512→\n   513→## Common Operations\n   514→\n   515→```javascript\n   516→// Upload initial consultation documents (no matter yet)\n   517→await storageService.uploadFile(\n   518→  file, \n   519→  teamId, \n   520→  'matter-client-abc-general',  // Client's general intake folder\n   521→  { \n   522→    displayName: 'Initial Tax Returns',\n   523→    clientIds: ['client-abc'],\n   524→    tags: ['intake', 'tax'],\n   525→    documentType: 'client-provided'\n   526→  }\n   527→)\n   528→\n   529→// Upload to a multi-client matter (husband & wife)\n   530→await storageService.uploadFile(\n   531→  file,\n   532→  teamId,\n   533→  'matter-smith-estate-001',\n   534→  {\n   535→    displayName: 'Joint Asset Declaration',\n   536→    clientIds: ['client-john-smith', 'client-jane-smith'],\n   537→    tags: ['estate', 'assets'],\n   538→    documentType: 'client-provided'\n   539→  }\n   540→)\n   541→\n   542→// Upload a team resource\n   543→await storageService.uploadFile(\n   544→  file,\n   545→  teamId,\n   546→  'matter-general',  // Team's general matter\n   547→  {\n   548→    displayName: 'Team Handbook 2024',\n   549→    clientIds: [],  // No clients for team documents\n   550→    tags: ['handbook', 'policy'],\n   551→    documentType: 'firm-generated'\n   552→  }\n   553→)\n   554→\n   555→// Move document reference from intake to formal matter (just update Firestore)\n   556→async function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n   557→  // Note: File stays in original location (no need to move in Storage)\n   558→  // Just create a new document reference pointing to same file\n   559→  const doc = await db\n   560→    .collection('teams').doc(teamId)\n   561→    .collection('documents').doc(documentId)\n   562→    .get()\n   563→  \n   564→  // Create new reference for the formal matter\n   565→  await db\n   566→    .collection('teams').doc(teamId)\n   567→    .collection('documents').add({\n   568→      ...doc.data(),\n   569→      matterId: toMatterId,\n   570→      associatedFrom: fromMatterId,\n   571→      associatedAt: new Date(),\n   572→      notes: 'Moved from client intake to formal matter'\n   573→    })\n   574→}\n   575→```\n   576→\n   577→## Required Indexes (Minimal)\n   578→\n   579→```javascript\n   580→// Just the essentials\n   581→[\n   582→  {\n   583→    collection: 'teams/{teamId}/documents',\n   584→    fields: [\n   585→      { field: 'matterId', order: 'ASCENDING' },\n   586→      { field: 'uploadedAt', order: 'DESCENDING' }\n   587→    ]\n   588→  },\n   589→  {\n   590→    collection: 'teams/{teamId}/documents',\n   591→    fields: [\n   592→      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n   593→      { field: 'uploadedAt', order: 'DESCENDING' }\n   594→    ]\n   595→  },\n   596→  {\n   597→    collection: 'teams/{teamId}/upload_attempts',\n   598→    fields: [\n   599→      { field: 'uploadedBy', order: 'ASCENDING' },\n   600→      { field: 'attemptedAt', order: 'DESCENDING' }\n   601→    ]\n   602→  }\n   603→]\n   604→```\n   605→\n   606→Remember: **Start simple, add complexity only when real usage patterns demand it.**\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"fc8e4ca1-e310-4b3b-890f-6fac9dae922d","timestamp":"2025-08-20T16:28:45.663Z","toolUseResult":{"type":"text","file":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","content":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload attempt record (ALWAYS, even for duplicates)\n    const attemptId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      attemptedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadAttemptId: attemptId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        attemptId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Attempts Log: `/teams/{teamId}/upload_attempts/{attemptId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  attemptedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload attempts\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_attempts/{attempt} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Attempts are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload Attempt is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","numLines":606,"startLine":1,"totalLines":606}}}
{"parentUuid":"fc8e4ca1-e310-4b3b-890f-6fac9dae922d","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01X5Xbj2azNXzdAwpyvmFRj5","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"According to the Firebase storage plan, attempted uploads are logged in a comprehensive way through the **Upload Attempts Log** collection.\n\nHere's how upload logging works:\n\n## Upload Attempts Collection\nEvery upload attempt creates a record in `/teams/{teamId}/upload_attempts/{attemptId}` with these fields:\n\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  attemptedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Key Logging Features\n\n1. **Every attempt is logged** - Whether successful, duplicate, or failed\n2. **Comprehensive metadata** - File details, destination, user, timestamp\n3. **Result tracking** - Success/failure, duplicate detection, error messages\n4. **Immutable records** - Upload attempts cannot be modified after creation\n\n## Example Scenarios\n\n- **New file**: `wasDuplicate: false, wasSuccessful: true`\n- **Duplicate detected**: `wasDuplicate: true, wasSuccessful: true` \n- **Upload failed**: `wasSuccessful: false, error: 'Network timeout'`\n\nThis creates a complete audit trail where you can track who attempted to upload what, when, where it was going, and what happened - even if the same file content was uploaded multiple times with different names to different matters."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":7188,"cache_read_input_tokens":20289,"cache_creation":{"ephemeral_5m_input_tokens":7188,"ephemeral_1h_input_tokens":0},"output_tokens":468,"service_tier":"standard"}},"requestId":"req_011CSKH4iJTsCv8XcjrZtMm7","type":"assistant","uuid":"3e476adb-cd04-499c-a9c0-bfc0023068e5","timestamp":"2025-08-20T16:28:57.060Z"}
{"parentUuid":"3e476adb-cd04-499c-a9c0-bfc0023068e5","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":"Are these logs stored in Firebase storage?  Or are they logged in Firestore?"},"uuid":"116bcce0-e055-4a44-adc1-2767a0948c75","timestamp":"2025-08-20T16:30:19.610Z"}
{"parentUuid":"116bcce0-e055-4a44-adc1-2767a0948c75","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01YAadNoksttkP63fGnKjVMv","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"The upload attempt logs are stored in **Firestore**, not Firebase Storage.\n\nSpecifically, they're stored in the Firestore collection:\n```\n/teams/{teamId}/upload_attempts/{attemptId}\n```\n\n## Why Firestore (not Firebase Storage):\n\n1. **Structured data** - Upload logs contain metadata, timestamps, user IDs, success flags, etc. that need to be queryable\n2. **Query capabilities** - You can search logs by user, date, matter, file hash, success status, etc.\n3. **Security rules** - Firestore security rules control who can read/write log entries\n4. **Immutable records** - Firestore rules prevent modification: `allow update, delete: if false`\n\n## What goes where:\n\n- **Firebase Storage**: The actual files (`teams/{teamId}/matters/{matterId}/{sha256}.{ext}`)\n- **Firestore**: \n  - Document metadata (`/teams/{teamId}/documents/{documentId}`)\n  - Upload attempt logs (`/teams/{teamId}/upload_attempts/{attemptId}`)\n  - Matter information, client data, etc.\n\nThis separation allows the actual files to be stored efficiently in Firebase Storage while keeping all the searchable metadata and audit logs in Firestore where they can be easily queried and secured with granular rules."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":492,"cache_read_input_tokens":27477,"cache_creation":{"ephemeral_5m_input_tokens":492,"ephemeral_1h_input_tokens":0},"output_tokens":302,"service_tier":"standard"}},"requestId":"req_011CSKHBeTyPKv9CuXsACdDs","type":"assistant","uuid":"bd23322b-7524-4201-8ed0-645ee12611a2","timestamp":"2025-08-20T16:30:28.462Z"}
{"parentUuid":"bd23322b-7524-4201-8ed0-645ee12611a2","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":"I would prefer the name \"upload_logs\" rather than \"upload_attempts\".   Attempts suggests that the upload failed.  Please update both documentation files."},"uuid":"7d0e3d7a-5b26-4036-993a-c5b3b028141d","timestamp":"2025-08-20T16:32:55.068Z"}
{"parentUuid":"7d0e3d7a-5b26-4036-993a-c5b3b028141d","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01PSgNBqjZ2xWgBrfybA91bG","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_011Tq9euxvAeCqW1yRjZdiAQ","name":"TodoWrite","input":{"todos":[{"id":"todo-1","content":"Update firebase-storage-plan.md to rename 'upload_attempts' to 'upload_logs'","status":"pending"},{"id":"todo-2","content":"Check if there are other documentation files that need the same update","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":338,"cache_read_input_tokens":27969,"cache_creation":{"ephemeral_5m_input_tokens":338,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CSKHP73wVHTkG1CBjQN6g","type":"assistant","uuid":"8b43520b-3328-46d9-a397-9aec9083f388","timestamp":"2025-08-20T16:32:58.745Z"}
{"parentUuid":"8b43520b-3328-46d9-a397-9aec9083f388","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011Tq9euxvAeCqW1yRjZdiAQ","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"c1fbaec6-1da3-41b5-9add-3bd7d4109965","timestamp":"2025-08-20T16:32:58.832Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Update firebase-storage-plan.md to rename 'upload_attempts' to 'upload_logs'","status":"pending","id":"todo-1"},{"content":"Check if there are other documentation files that need the same update","status":"pending","id":"todo-2"}]}}
{"parentUuid":"c1fbaec6-1da3-41b5-9add-3bd7d4109965","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01SPD9y9xxvbN4Ej8h2AV912","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01ELC4KhhE2rS7AC2sDZoFPv","name":"TodoWrite","input":{"todos":[{"id":"todo-1","content":"Update firebase-storage-plan.md to rename 'upload_attempts' to 'upload_logs'","status":"in_progress"},{"id":"todo-2","content":"Check if there are other documentation files that need the same update","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":281,"cache_read_input_tokens":28307,"cache_creation":{"ephemeral_5m_input_tokens":281,"ephemeral_1h_input_tokens":0},"output_tokens":33,"service_tier":"standard"}},"requestId":"req_011CSKHPNnV9rLdyU6tX1qXK","type":"assistant","uuid":"fa4d307e-822c-4e40-8908-d12604ff8368","timestamp":"2025-08-20T16:33:01.617Z"}
{"parentUuid":"fa4d307e-822c-4e40-8908-d12604ff8368","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ELC4KhhE2rS7AC2sDZoFPv","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"62527733-a27a-47c1-810b-06068f96e6e9","timestamp":"2025-08-20T16:33:01.719Z","toolUseResult":{"oldTodos":[{"content":"Update firebase-storage-plan.md to rename 'upload_attempts' to 'upload_logs'","status":"pending","id":"todo-1"},{"content":"Check if there are other documentation files that need the same update","status":"pending","id":"todo-2"}],"newTodos":[{"content":"Update firebase-storage-plan.md to rename 'upload_attempts' to 'upload_logs'","status":"in_progress","id":"todo-1"},{"content":"Check if there are other documentation files that need the same update","status":"pending","id":"todo-2"}]}}
{"parentUuid":"62527733-a27a-47c1-810b-06068f96e6e9","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01CtmJG6dKbQU4EVPnG1WAsa","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01Ucn833zcBKo1bfcHmLhBee","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"    // 2. Create upload attempt record (ALWAYS, even for duplicates)\n    const attemptId = await this.logUploadAttempt({","new_string":"    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":287,"cache_read_input_tokens":28588,"cache_creation":{"ephemeral_5m_input_tokens":287,"ephemeral_1h_input_tokens":0},"output_tokens":181,"service_tier":"standard"}},"requestId":"req_011CSKHPb3BNGteTdrJdzVpM","type":"assistant","uuid":"7c7e70ac-e6d4-4bce-af58-4ee37f525339","timestamp":"2025-08-20T16:33:06.779Z"}
{"parentUuid":"7c7e70ac-e6d4-4bce-af58-4ee37f525339","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ucn833zcBKo1bfcHmLhBee","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    73→    const extension = file.name.split('.').pop().toLowerCase()\n    74→    const fileName = `${fileHash}.${extension}`\n    75→    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    76→    \n    77→    // 2. Create upload log record (ALWAYS, even for duplicates)\n    78→    const logId = await this.logUploadAttempt({\n    79→      teamId,\n    80→      matterId,\n    81→      fileName: file.name,\n    82→      fileHash,"}]},"uuid":"a0c8ca18-47d1-4d6f-8249-17f62f937848","timestamp":"2025-08-20T16:33:08.471Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"    // 2. Create upload attempt record (ALWAYS, even for duplicates)\n    const attemptId = await this.logUploadAttempt({","newString":"    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload attempt record (ALWAYS, even for duplicates)\n    const attemptId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      attemptedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadAttemptId: attemptId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        attemptId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Attempts Log: `/teams/{teamId}/upload_attempts/{attemptId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  attemptedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload attempts\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_attempts/{attempt} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Attempts are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload Attempt is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":74,"oldLines":8,"newStart":74,"newLines":8,"lines":["     const fileName = `${fileHash}.${extension}`","     const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`","     ","-    // 2. Create upload attempt record (ALWAYS, even for duplicates)","-    const attemptId = await this.logUploadAttempt({","+    // 2. Create upload log record (ALWAYS, even for duplicates)","+    const logId = await this.logUploadAttempt({","       teamId,","       matterId,","       fileName: file.name,"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"a0c8ca18-47d1-4d6f-8249-17f62f937848","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_017UZHU5k5Roi1vfLQVSRrvj","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01THEBVqKYftRUVghWKPooY3","name":"MultiEdit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","edits":[{"old_string":"      uploadedBy: auth.currentUser.uid,\n      attemptedAt: new Date()\n    })","new_string":"      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })"},{"old_string":"        originalUploadAttemptId: attemptId","new_string":"        originalUploadLogId: logId"},{"old_string":"        attemptId\n      }","new_string":"        logId\n      }"},{"old_string":"        originalUploadAttemptId: attemptId","new_string":"        originalUploadLogId: logId"},{"old_string":"      attemptId\n    }","new_string":"      logId\n    }"},{"old_string":"#### Upload Attempts Log: `/teams/{teamId}/upload_attempts/{attemptId}`","new_string":"#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`"},{"old_string":"  uploadedBy: 'user-123',\n  attemptedAt: Timestamp,","new_string":"  uploadedBy: 'user-123',\n  loggedAt: Timestamp,"},{"old_string":"    match /teams/{teamId}/upload_attempts/{attempt} {","new_string":"    match /teams/{teamId}/upload_logs/{log} {"},{"old_string":"                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Attempts are immutable","new_string":"                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Logs are immutable"},{"old_string":"### Every Upload Attempt is Logged","new_string":"### Every Upload is Logged"},{"old_string":"// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',","new_string":"// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_logs records\n\n// Log 1: New file to matter-123\n{\n  logId: 'log-001',"},{"old_string":"// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',","new_string":"// Log 2: Same file to matter-456\n{\n  logId: 'log-002',"},{"old_string":"// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',","new_string":"// Log 3: Upload failed (network error)\n{\n  logId: 'log-003',"},{"old_string":"// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')","new_string":"// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')"},{"old_string":"  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')","new_string":"  .where('uploadedBy', '==', userId)\n  .orderBy('loggedAt', 'desc')"},{"old_string":"// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')","new_string":"// Find duplicate uploads\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')"},{"old_string":"// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')","new_string":"// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')"},{"old_string":"  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')","new_string":"  .where('fileHash', '==', fileHash)\n  .orderBy('loggedAt', 'desc')"},{"old_string":"- [ ] Upload attempt logging","new_string":"- [ ] Upload logging"},{"old_string":"    collection: 'teams/{teamId}/upload_attempts',","new_string":"    collection: 'teams/{teamId}/upload_logs',"},{"old_string":"      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }","new_string":"      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'loggedAt', order: 'DESCENDING' }"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":382,"cache_read_input_tokens":28875,"cache_creation":{"ephemeral_5m_input_tokens":382,"ephemeral_1h_input_tokens":0},"output_tokens":1598,"service_tier":"standard"}},"requestId":"req_011CSKHQ5zDaebXL3Wz7vZc2","type":"assistant","uuid":"47056a17-fe4c-453e-b9ea-ca06aee9fc4a","timestamp":"2025-08-20T16:33:27.604Z"}
{"parentUuid":"47056a17-fe4c-453e-b9ea-ca06aee9fc4a","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"String not found in file. Failed to apply edit.","is_error":true,"tool_use_id":"toolu_01THEBVqKYftRUVghWKPooY3"}]},"uuid":"15505fba-2445-4a1b-932d-803ee4e9a153","timestamp":"2025-08-20T16:33:27.696Z","toolUseResult":"Error: String not found in file. Failed to apply edit."}
{"parentUuid":"15505fba-2445-4a1b-932d-803ee4e9a153","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01HnyzQsiERihK6wih67kjPX","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01Awq3UTcXTP99cR1HYN76QL","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"      uploadedBy: auth.currentUser.uid,\n      attemptedAt: new Date()\n    })","new_string":"      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":1436,"cache_read_input_tokens":29257,"cache_creation":{"ephemeral_5m_input_tokens":1436,"ephemeral_1h_input_tokens":0},"output_tokens":161,"service_tier":"standard"}},"requestId":"req_011CSKHRW65s7LLRuHzo24MV","type":"assistant","uuid":"4ff51129-bc7a-47ca-afd6-a31d07aa308f","timestamp":"2025-08-20T16:33:32.680Z"}
{"parentUuid":"4ff51129-bc7a-47ca-afd6-a31d07aa308f","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Awq3UTcXTP99cR1HYN76QL","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    83→      storagePath,\n    84→      fileSize: file.size,\n    85→      mimeType: file.type,\n    86→      metadata,\n    87→      uploadedBy: auth.currentUser.uid,\n    88→      loggedAt: new Date()\n    89→    })\n    90→    \n    91→    // 3. Check if file exists\n    92→    const fileRef = storage.ref(storagePath)\n    93→    const exists = await this.checkFileExists(fileRef)"}]},"uuid":"8247163d-4f8f-4c29-bd0b-757e497b5f8e","timestamp":"2025-08-20T16:33:32.726Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"      uploadedBy: auth.currentUser.uid,\n      attemptedAt: new Date()\n    })","newString":"      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      attemptedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadAttemptId: attemptId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        attemptId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Attempts Log: `/teams/{teamId}/upload_attempts/{attemptId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  attemptedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload attempts\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_attempts/{attempt} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Attempts are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload Attempt is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":85,"oldLines":7,"newStart":85,"newLines":7,"lines":["       mimeType: file.type,","       metadata,","       uploadedBy: auth.currentUser.uid,","-      attemptedAt: new Date()","+      loggedAt: new Date()","     })","     ","     // 3. Check if file exists"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"8247163d-4f8f-4c29-bd0b-757e497b5f8e","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_019rmsLpVqTPA2qrCikDma51","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01B5uRzpcnKFzBKkix6HvXS6","name":"Edit","input":{"replace_all":true,"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"        originalUploadAttemptId: attemptId","new_string":"        originalUploadLogId: logId"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":351,"cache_read_input_tokens":30693,"cache_creation":{"ephemeral_5m_input_tokens":351,"ephemeral_1h_input_tokens":0},"output_tokens":152,"service_tier":"standard"}},"requestId":"req_011CSKHRsYvArbYy4d35qJx6","type":"assistant","uuid":"129f940b-5ab4-4665-b7eb-41648c04a2da","timestamp":"2025-08-20T16:33:36.396Z"}
{"parentUuid":"129f940b-5ab4-4665-b7eb-41648c04a2da","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B5uRzpcnKFzBKkix6HvXS6","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. All occurrences of '        originalUploadAttemptId: attemptId' were successfully replaced with '        originalUploadLogId: logId'."}]},"uuid":"767f7e85-fddf-48df-a418-6e3e3fed8089","timestamp":"2025-08-20T16:33:36.444Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"        originalUploadAttemptId: attemptId","newString":"        originalUploadLogId: logId","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadAttemptId: attemptId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        attemptId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Attempts Log: `/teams/{teamId}/upload_attempts/{attemptId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  attemptedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload attempts\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_attempts/{attempt} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Attempts are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload Attempt is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":99,"oldLines":7,"newStart":99,"newLines":7,"lines":["         fileHash,","         storagePath,","         isDuplicate: true,","-        originalUploadAttemptId: attemptId","+        originalUploadLogId: logId","       })","       ","       return { "]}],"userModified":false,"replaceAll":true}}
{"parentUuid":"767f7e85-fddf-48df-a418-6e3e3fed8089","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01BNGwtUPEDTTrhdoeBvWpqm","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01YDMvLZ8VKugdmZcQ3wnSmV","name":"Edit","input":{"replace_all":true,"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"        attemptId","new_string":"        logId"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":228,"cache_read_input_tokens":31044,"cache_creation":{"ephemeral_5m_input_tokens":228,"ephemeral_1h_input_tokens":0},"output_tokens":138,"service_tier":"standard"}},"requestId":"req_011CSKHS9YqZtrsP2WBPGWEv","type":"assistant","uuid":"274cdf58-39bc-48a9-ba43-07eec6604398","timestamp":"2025-08-20T16:33:39.255Z"}
{"parentUuid":"274cdf58-39bc-48a9-ba43-07eec6604398","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YDMvLZ8VKugdmZcQ3wnSmV","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. All occurrences of '        attemptId' were successfully replaced with '        logId'."}]},"uuid":"73868878-2012-47f6-bae7-87476585d18e","timestamp":"2025-08-20T16:33:39.325Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"        attemptId","newString":"        logId","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        attemptId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Attempts Log: `/teams/{teamId}/upload_attempts/{attemptId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  attemptedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload attempts\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_attempts/{attempt} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Attempts are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload Attempt is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":106,"oldLines":7,"newStart":106,"newLines":7,"lines":["         success: true, ","         isDuplicate: true,","         storagePath,","-        attemptId","+        logId","       }","     }","     "]}],"userModified":false,"replaceAll":true}}
{"parentUuid":"73868878-2012-47f6-bae7-87476585d18e","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01JWXukKGQGRbMu1uCRe8uba","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_019sBifMf66kw4ax16wsmVGZ","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"#### Upload Attempts Log: `/teams/{teamId}/upload_attempts/{attemptId}`","new_string":"#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":200,"cache_read_input_tokens":31272,"cache_creation":{"ephemeral_5m_input_tokens":200,"ephemeral_1h_input_tokens":0},"output_tokens":150,"service_tier":"standard"}},"requestId":"req_011CSKHSMwiR2qnvRh7v43ps","type":"assistant","uuid":"cc5b9fda-0734-43f8-a953-27101d000e6d","timestamp":"2025-08-20T16:33:42.352Z"}
{"parentUuid":"cc5b9fda-0734-43f8-a953-27101d000e6d","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019sBifMf66kw4ax16wsmVGZ","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   168→  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n   169→}\n   170→```\n   171→\n   172→#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n   173→```javascript\n   174→{\n   175→  // What was attempted\n   176→  fileName: 'Contract ABC Corp.pdf',"}]},"uuid":"10e32b31-604d-45ac-b50c-963018f3fdc3","timestamp":"2025-08-20T16:33:42.405Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"#### Upload Attempts Log: `/teams/{teamId}/upload_attempts/{attemptId}`","newString":"#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Attempts Log: `/teams/{teamId}/upload_attempts/{attemptId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  attemptedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload attempts\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_attempts/{attempt} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Attempts are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload Attempt is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":169,"oldLines":7,"newStart":169,"newLines":7,"lines":[" }"," ```"," ","-#### Upload Attempts Log: `/teams/{teamId}/upload_attempts/{attemptId}`","+#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`"," ```javascript"," {","   // What was attempted"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"10e32b31-604d-45ac-b50c-963018f3fdc3","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01A1RxneWNKCxLMPR9hAAMfp","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_015V68PkZB6YpxDhHmvZhbZf","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"  uploadedBy: 'user-123',\n  attemptedAt: Timestamp,","new_string":"  uploadedBy: 'user-123',\n  loggedAt: Timestamp,"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":320,"cache_read_input_tokens":31472,"cache_creation":{"ephemeral_5m_input_tokens":320,"ephemeral_1h_input_tokens":0},"output_tokens":153,"service_tier":"standard"}},"requestId":"req_011CSKHSb5kNZExZWR2Grjdt","type":"assistant","uuid":"e8161e04-4df9-4f2b-a856-df304f5d94fc","timestamp":"2025-08-20T16:33:45.237Z"}
{"parentUuid":"e8161e04-4df9-4f2b-a856-df304f5d94fc","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015V68PkZB6YpxDhHmvZhbZf","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   182→  matterId: 'matter-123',\n   183→  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n   184→  \n   185→  // Who and when\n   186→  uploadedBy: 'user-123',\n   187→  loggedAt: Timestamp,\n   188→  \n   189→  // Result\n   190→  wasSuccessful: true,              // false if error\n   191→  wasDuplicate: false,              // true if file already existed"}]},"uuid":"36c0cd29-bcaf-488c-89d9-4dafec13ca2e","timestamp":"2025-08-20T16:33:45.297Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"  uploadedBy: 'user-123',\n  attemptedAt: Timestamp,","newString":"  uploadedBy: 'user-123',\n  loggedAt: Timestamp,","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  attemptedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload attempts\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_attempts/{attempt} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Attempts are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload Attempt is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":184,"oldLines":7,"newStart":184,"newLines":7,"lines":["   ","   // Who and when","   uploadedBy: 'user-123',","-  attemptedAt: Timestamp,","+  loggedAt: Timestamp,","   ","   // Result","   wasSuccessful: true,              // false if error"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"36c0cd29-bcaf-488c-89d9-4dafec13ca2e","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_018GMj2ufBiq6TNxY4HF2vfH","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01JZbm9j2YGVaFD6tPJ7mAFK","name":"Edit","input":{"replace_all":true,"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"    match /teams/{teamId}/upload_attempts/{attempt} {","new_string":"    match /teams/{teamId}/upload_logs/{log} {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":341,"cache_read_input_tokens":31792,"cache_creation":{"ephemeral_5m_input_tokens":341,"ephemeral_1h_input_tokens":0},"output_tokens":161,"service_tier":"standard"}},"requestId":"req_011CSKHSoMBaFRmaCBT4Aj6U","type":"assistant","uuid":"b86156ff-2a9c-4935-9049-0bf24429a39a","timestamp":"2025-08-20T16:33:47.949Z"}
{"parentUuid":"b86156ff-2a9c-4935-9049-0bf24429a39a","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JZbm9j2YGVaFD6tPJ7mAFK","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. All occurrences of '    match /teams/{teamId}/upload_attempts/{attempt} {' were successfully replaced with '    match /teams/{teamId}/upload_logs/{log} {'."}]},"uuid":"763b7da0-4fdd-4fdf-b037-92d7c7640217","timestamp":"2025-08-20T16:33:48.006Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"    match /teams/{teamId}/upload_attempts/{attempt} {","newString":"    match /teams/{teamId}/upload_logs/{log} {","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  loggedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload attempts\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_attempts/{attempt} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Attempts are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload Attempt is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":228,"oldLines":7,"newStart":228,"newLines":7,"lines":["       allow update, delete: if false;  // Documents are immutable","     }","     ","-    match /teams/{teamId}/upload_attempts/{attempt} {","+    match /teams/{teamId}/upload_logs/{log} {","       allow read: if request.auth != null && ","                      request.auth.token.teamId == teamId;","       allow create: if request.auth != null && "]}],"userModified":false,"replaceAll":true}}
{"parentUuid":"763b7da0-4fdd-4fdf-b037-92d7c7640217","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01MQsgPyYicfBkEsLXZ43ov4","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_013zB1AqgQUiiMQQB8mDzSEQ","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"    // Team members can read all team documents and upload attempts","new_string":"    // Team members can read all team documents and upload logs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":246,"cache_read_input_tokens":32133,"cache_creation":{"ephemeral_5m_input_tokens":246,"ephemeral_1h_input_tokens":0},"output_tokens":136,"service_tier":"standard"}},"requestId":"req_011CSKHSzzAxDdpvuVcfLywt","type":"assistant","uuid":"f41e8f48-3f51-4c7a-b0cf-13ca4922bcc1","timestamp":"2025-08-20T16:33:51.247Z"}
{"parentUuid":"f41e8f48-3f51-4c7a-b0cf-13ca4922bcc1","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013zB1AqgQUiiMQQB8mDzSEQ","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   218→```javascript\n   219→rules_version = '2';\n   220→service cloud.firestore {\n   221→  match /databases/{database}/documents {\n   222→    // Team members can read all team documents and upload logs\n   223→    match /teams/{teamId}/documents/{doc} {\n   224→      allow read: if request.auth != null && \n   225→                     request.auth.token.teamId == teamId;\n   226→      allow create: if request.auth != null && "}]},"uuid":"792240b0-ee0d-4653-aaf4-5db2bf977680","timestamp":"2025-08-20T16:33:51.301Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"    // Team members can read all team documents and upload attempts","newString":"    // Team members can read all team documents and upload logs","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  loggedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload attempts\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_logs/{log} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Attempts are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload Attempt is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":219,"oldLines":7,"newStart":219,"newLines":7,"lines":[" rules_version = '2';"," service cloud.firestore {","   match /databases/{database}/documents {","-    // Team members can read all team documents and upload attempts","+    // Team members can read all team documents and upload logs","     match /teams/{teamId}/documents/{doc} {","       allow read: if request.auth != null && ","                      request.auth.token.teamId == teamId;"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"792240b0-ee0d-4653-aaf4-5db2bf977680","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01Q2GzvTphaGKku4hRYwWjnP","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01F2aD47WJfCibE2KVrWE6NF","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"      allow update, delete: if false;  // Attempts are immutable","new_string":"      allow update, delete: if false;  // Logs are immutable"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":320,"cache_read_input_tokens":32379,"cache_creation":{"ephemeral_5m_input_tokens":320,"ephemeral_1h_input_tokens":0},"output_tokens":144,"service_tier":"standard"}},"requestId":"req_011CSKHTExZ7LWQzkd8NwEBp","type":"assistant","uuid":"f270522e-aecb-462e-bdaf-8a242f1e79ea","timestamp":"2025-08-20T16:33:54.342Z"}
{"parentUuid":"f270522e-aecb-462e-bdaf-8a242f1e79ea","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F2aD47WJfCibE2KVrWE6NF","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   232→      allow read: if request.auth != null && \n   233→                     request.auth.token.teamId == teamId;\n   234→      allow create: if request.auth != null && \n   235→                       request.auth.token.teamId == teamId;\n   236→      allow update, delete: if false;  // Logs are immutable\n   237→    }\n   238→  }\n   239→}\n   240→```"}]},"uuid":"d4ad2fd6-ea02-4596-a210-c0e246a734d2","timestamp":"2025-08-20T16:33:54.414Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"      allow update, delete: if false;  // Attempts are immutable","newString":"      allow update, delete: if false;  // Logs are immutable","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  loggedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload logs\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_logs/{log} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Attempts are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload Attempt is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":233,"oldLines":7,"newStart":233,"newLines":7,"lines":["                      request.auth.token.teamId == teamId;","       allow create: if request.auth != null && ","                        request.auth.token.teamId == teamId;","-      allow update, delete: if false;  // Attempts are immutable","+      allow update, delete: if false;  // Logs are immutable","     }","   }"," }"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"d4ad2fd6-ea02-4596-a210-c0e246a734d2","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01CcXNCHcQtAAHxNknumPxUR","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01M6u74TQgo4441o1MvDUmZV","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"### Every Upload Attempt is Logged","new_string":"### Every Upload is Logged"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":315,"cache_read_input_tokens":32699,"cache_creation":{"ephemeral_5m_input_tokens":315,"ephemeral_1h_input_tokens":0},"output_tokens":126,"service_tier":"standard"}},"requestId":"req_011CSKHTUNCkWQha6gZdXWsT","type":"assistant","uuid":"eb095fa5-6f52-40b4-ac77-fb37dfcf8388","timestamp":"2025-08-20T16:33:57.017Z"}
{"parentUuid":"eb095fa5-6f52-40b4-ac77-fb37dfcf8388","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M6u74TQgo4441o1MvDUmZV","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   282→```\n   283→\n   284→## Tracking & Audit Trail\n   285→\n   286→### Every Upload is Logged\n   287→```javascript\n   288→// Example: User uploads same file 3 times to different matters\n   289→// Result: 1 file in storage, 3 upload_attempts records\n   290→"}]},"uuid":"34c56613-4de2-4f50-976a-39a1cf2b88a5","timestamp":"2025-08-20T16:33:57.084Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"### Every Upload Attempt is Logged","newString":"### Every Upload is Logged","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  loggedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload logs\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_logs/{log} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Logs are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload Attempt is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":283,"oldLines":7,"newStart":283,"newLines":7,"lines":[" "," ## Tracking & Audit Trail"," ","-### Every Upload Attempt is Logged","+### Every Upload is Logged"," ```javascript"," // Example: User uploads same file 3 times to different matters"," // Result: 1 file in storage, 3 upload_attempts records"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"34c56613-4de2-4f50-976a-39a1cf2b88a5","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01NmDJdZMP6FL5AVBiExpCjU","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01LznRHqGfA9tQt11jeYnawj","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',","new_string":"// Result: 1 file in storage, 3 upload_logs records\n\n// Log 1: New file to matter-123\n{\n  logId: 'log-001',"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":270,"cache_read_input_tokens":33014,"cache_creation":{"ephemeral_5m_input_tokens":270,"ephemeral_1h_input_tokens":0},"output_tokens":198,"service_tier":"standard"}},"requestId":"req_011CSKHTfiKxKx7Akf4tSB5Q","type":"assistant","uuid":"44d79729-54d8-4cb9-b82f-f200ce24655f","timestamp":"2025-08-20T16:34:00.582Z"}
{"parentUuid":"44d79729-54d8-4cb9-b82f-f200ce24655f","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LznRHqGfA9tQt11jeYnawj","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   285→\n   286→### Every Upload is Logged\n   287→```javascript\n   288→// Example: User uploads same file 3 times to different matters\n   289→// Result: 1 file in storage, 3 upload_logs records\n   290→\n   291→// Log 1: New file to matter-123\n   292→{\n   293→  logId: 'log-001',\n   294→  fileName: 'Contract.pdf',\n   295→  fileHash: 'abc123',\n   296→  matterId: 'matter-123',\n   297→  wasDuplicate: false,  // First upload"}]},"uuid":"52bb4e06-dfbb-46dc-829a-70336b1d9f45","timestamp":"2025-08-20T16:34:00.637Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',","newString":"// Result: 1 file in storage, 3 upload_logs records\n\n// Log 1: New file to matter-123\n{\n  logId: 'log-001',","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  loggedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload logs\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_logs/{log} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Logs are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_attempts records\n\n// Attempt 1: New file to matter-123\n{\n  attemptId: 'attempt-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":286,"oldLines":11,"newStart":286,"newLines":11,"lines":[" ### Every Upload is Logged"," ```javascript"," // Example: User uploads same file 3 times to different matters","-// Result: 1 file in storage, 3 upload_attempts records","+// Result: 1 file in storage, 3 upload_logs records"," ","-// Attempt 1: New file to matter-123","+// Log 1: New file to matter-123"," {","-  attemptId: 'attempt-001',","+  logId: 'log-001',","   fileName: 'Contract.pdf',","   fileHash: 'abc123',","   matterId: 'matter-123',"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"52bb4e06-dfbb-46dc-829a-70336b1d9f45","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01WJFHynyzH6UD7Z8iJXAQqS","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01UQJ1LsHBHXiDpb9XhSGSwb","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',","new_string":"// Log 2: Same file to matter-456\n{\n  logId: 'log-002',"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":412,"cache_read_input_tokens":33284,"cache_creation":{"ephemeral_5m_input_tokens":412,"ephemeral_1h_input_tokens":0},"output_tokens":162,"service_tier":"standard"}},"requestId":"req_011CSKHTw2Kqr67YceYKjtF9","type":"assistant","uuid":"4219439f-9eb6-494f-8462-7f3d2bd6411f","timestamp":"2025-08-20T16:34:03.418Z"}
{"parentUuid":"4219439f-9eb6-494f-8462-7f3d2bd6411f","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UQJ1LsHBHXiDpb9XhSGSwb","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   297→  wasDuplicate: false,  // First upload\n   298→  wasSuccessful: true\n   299→}\n   300→\n   301→// Log 2: Same file to matter-456\n   302→{\n   303→  logId: 'log-002',\n   304→  fileName: 'Contract_Final.pdf',  // Different name, same content\n   305→  fileHash: 'abc123',              // Same hash!\n   306→  matterId: 'matter-456',\n   307→  wasDuplicate: true,               // Detected duplicate"}]},"uuid":"d4ba0757-2648-41cb-9387-34de28a65e87","timestamp":"2025-08-20T16:34:03.479Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',","newString":"// Log 2: Same file to matter-456\n{\n  logId: 'log-002',","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  loggedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload logs\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_logs/{log} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Logs are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_logs records\n\n// Log 1: New file to matter-123\n{\n  logId: 'log-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Attempt 2: Same file to matter-456\n{\n  attemptId: 'attempt-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":298,"oldLines":9,"newStart":298,"newLines":9,"lines":["   wasSuccessful: true"," }"," ","-// Attempt 2: Same file to matter-456","+// Log 2: Same file to matter-456"," {","-  attemptId: 'attempt-002',","+  logId: 'log-002',","   fileName: 'Contract_Final.pdf',  // Different name, same content","   fileHash: 'abc123',              // Same hash!","   matterId: 'matter-456',"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"d4ba0757-2648-41cb-9387-34de28a65e87","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_018AJfPUq4yS9dV8mkZB75TF","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01LjWdZhmbiyxfYthNAbCruY","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',","new_string":"// Log 3: Upload failed (network error)\n{\n  logId: 'log-003',"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":364,"cache_read_input_tokens":33696,"cache_creation":{"ephemeral_5m_input_tokens":364,"ephemeral_1h_input_tokens":0},"output_tokens":162,"service_tier":"standard"}},"requestId":"req_011CSKHU9PDm7wvVKTUApUFP","type":"assistant","uuid":"202fc791-ed1d-40b2-8d8f-be8a353b5447","timestamp":"2025-08-20T16:34:07.079Z"}
{"parentUuid":"202fc791-ed1d-40b2-8d8f-be8a353b5447","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LjWdZhmbiyxfYthNAbCruY","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   307→  wasDuplicate: true,               // Detected duplicate\n   308→  wasSuccessful: true\n   309→}\n   310→\n   311→// Log 3: Upload failed (network error)\n   312→{\n   313→  logId: 'log-003',\n   314→  fileName: 'Contract.pdf',\n   315→  fileHash: 'abc123',\n   316→  matterId: 'matter-789',\n   317→  wasDuplicate: true,"}]},"uuid":"412a65f5-6749-4ab5-acee-b2b041064b7c","timestamp":"2025-08-20T16:34:07.130Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',","newString":"// Log 3: Upload failed (network error)\n{\n  logId: 'log-003',","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  loggedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload logs\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_logs/{log} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Logs are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_logs records\n\n// Log 1: New file to matter-123\n{\n  logId: 'log-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Log 2: Same file to matter-456\n{\n  logId: 'log-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Attempt 3: Upload failed (network error)\n{\n  attemptId: 'attempt-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":308,"oldLines":9,"newStart":308,"newLines":9,"lines":["   wasSuccessful: true"," }"," ","-// Attempt 3: Upload failed (network error)","+// Log 3: Upload failed (network error)"," {","-  attemptId: 'attempt-003',","+  logId: 'log-003',","   fileName: 'Contract.pdf',","   fileHash: 'abc123',","   matterId: 'matter-789',"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"412a65f5-6749-4ab5-acee-b2b041064b7c","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_013QVHJMDid1GTY4KtoQwwHp","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_015sHf7SfZYhQWmNfAEHHenX","name":"Edit","input":{"replace_all":true,"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"  .collection('upload_attempts')","new_string":"  .collection('upload_logs')"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":346,"cache_read_input_tokens":34060,"cache_creation":{"ephemeral_5m_input_tokens":346,"ephemeral_1h_input_tokens":0},"output_tokens":147,"service_tier":"standard"}},"requestId":"req_011CSKHUQdkHQCuiMejcjSGo","type":"assistant","uuid":"7026f55f-3c4f-4047-a19d-95c7dccd993d","timestamp":"2025-08-20T16:34:10.106Z"}
{"parentUuid":"7026f55f-3c4f-4047-a19d-95c7dccd993d","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015sHf7SfZYhQWmNfAEHHenX","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. All occurrences of '  .collection('upload_attempts')' were successfully replaced with '  .collection('upload_logs')'."}]},"uuid":"5e95b0c1-f9bb-45b6-89f8-1592910c5aee","timestamp":"2025-08-20T16:34:10.153Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"  .collection('upload_attempts')","newString":"  .collection('upload_logs')","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  loggedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload logs\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_logs/{log} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Logs are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_logs records\n\n// Log 1: New file to matter-123\n{\n  logId: 'log-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Log 2: Same file to matter-456\n{\n  logId: 'log-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Log 3: Upload failed (network error)\n{\n  logId: 'log-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_attempts')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":342,"oldLines":7,"newStart":342,"newLines":7,"lines":[" // Find all uploads by a user"," const userUploads = await db","   .collection('teams').doc(teamId)","-  .collection('upload_attempts')","+  .collection('upload_logs')","   .where('uploadedBy', '==', userId)","   .orderBy('attemptedAt', 'desc')","   .get()"]},{"oldStart":350,"oldLines":14,"newStart":350,"newLines":14,"lines":[" // Find duplicate upload attempts"," const duplicates = await db","   .collection('teams').doc(teamId)","-  .collection('upload_attempts')","+  .collection('upload_logs')","   .where('wasDuplicate', '==', true)","   .get()"," "," // Get upload history for a specific file hash"," const fileHistory = await db","   .collection('teams').doc(teamId)","-  .collection('upload_attempts')","+  .collection('upload_logs')","   .where('fileHash', '==', fileHash)","   .orderBy('attemptedAt', 'desc')","   .get()"]}],"userModified":false,"replaceAll":true}}
{"parentUuid":"5e95b0c1-f9bb-45b6-89f8-1592910c5aee","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_011z9sfWverGjWubNamBAKmD","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_017uHqG39GCXF55L9YofmRMr","name":"Edit","input":{"replace_all":true,"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"  .orderBy('attemptedAt', 'desc')","new_string":"  .orderBy('loggedAt', 'desc')"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":218,"cache_read_input_tokens":34406,"cache_creation":{"ephemeral_5m_input_tokens":218,"ephemeral_1h_input_tokens":0},"output_tokens":158,"service_tier":"standard"}},"requestId":"req_011CSKHUdb7m38B8TyUuMvFw","type":"assistant","uuid":"74e166b9-af24-4f8e-9e3d-ee0aa87469ff","timestamp":"2025-08-20T16:34:13.131Z"}
{"parentUuid":"74e166b9-af24-4f8e-9e3d-ee0aa87469ff","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017uHqG39GCXF55L9YofmRMr","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. All occurrences of '  .orderBy('attemptedAt', 'desc')' were successfully replaced with '  .orderBy('loggedAt', 'desc')'."}]},"uuid":"00a5c805-4245-4bc8-b6b9-8e7b3de2e6b4","timestamp":"2025-08-20T16:34:13.181Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"  .orderBy('attemptedAt', 'desc')","newString":"  .orderBy('loggedAt', 'desc')","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  loggedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload logs\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_logs/{log} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Logs are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_logs records\n\n// Log 1: New file to matter-123\n{\n  logId: 'log-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Log 2: Same file to matter-456\n{\n  logId: 'log-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Log 3: Upload failed (network error)\n{\n  logId: 'log-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')\n  .where('uploadedBy', '==', userId)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')\n  .where('fileHash', '==', fileHash)\n  .orderBy('attemptedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":344,"oldLines":7,"newStart":344,"newLines":7,"lines":["   .collection('teams').doc(teamId)","   .collection('upload_logs')","   .where('uploadedBy', '==', userId)","-  .orderBy('attemptedAt', 'desc')","+  .orderBy('loggedAt', 'desc')","   .get()"," "," // Find duplicate upload attempts"]},{"oldStart":359,"oldLines":7,"newStart":359,"newLines":7,"lines":["   .collection('teams').doc(teamId)","   .collection('upload_logs')","   .where('fileHash', '==', fileHash)","-  .orderBy('attemptedAt', 'desc')","+  .orderBy('loggedAt', 'desc')","   .get()"," "," // Find all documents for a multi-client matter"]}],"userModified":false,"replaceAll":true}}
{"parentUuid":"00a5c805-4245-4bc8-b6b9-8e7b3de2e6b4","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01HmfMVE7GGWpXs5XxvvNHu8","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01U7X2Sv1FRyvAZxHimEcgy6","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"// Find duplicate upload attempts","new_string":"// Find duplicate uploads"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":240,"cache_read_input_tokens":34624,"cache_creation":{"ephemeral_5m_input_tokens":240,"ephemeral_1h_input_tokens":0},"output_tokens":121,"service_tier":"standard"}},"requestId":"req_011CSKHUrXjg3M5dxYFfgBtr","type":"assistant","uuid":"3e987e31-37ee-4d38-9e71-362cd42b7681","timestamp":"2025-08-20T16:34:16.240Z"}
{"parentUuid":"3e987e31-37ee-4d38-9e71-362cd42b7681","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01U7X2Sv1FRyvAZxHimEcgy6","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   346→  .where('uploadedBy', '==', userId)\n   347→  .orderBy('loggedAt', 'desc')\n   348→  .get()\n   349→\n   350→// Find duplicate uploads\n   351→const duplicates = await db\n   352→  .collection('teams').doc(teamId)\n   353→  .collection('upload_logs')\n   354→  .where('wasDuplicate', '==', true)"}]},"uuid":"2e630be8-96f7-465b-a43b-0ee6d8a6b18a","timestamp":"2025-08-20T16:34:16.285Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"// Find duplicate upload attempts","newString":"// Find duplicate uploads","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  loggedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload logs\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_logs/{log} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Logs are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_logs records\n\n// Log 1: New file to matter-123\n{\n  logId: 'log-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Log 2: Same file to matter-456\n{\n  logId: 'log-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Log 3: Upload failed (network error)\n{\n  logId: 'log-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')\n  .where('uploadedBy', '==', userId)\n  .orderBy('loggedAt', 'desc')\n  .get()\n\n// Find duplicate upload attempts\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')\n  .where('fileHash', '==', fileHash)\n  .orderBy('loggedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":347,"oldLines":7,"newStart":347,"newLines":7,"lines":["   .orderBy('loggedAt', 'desc')","   .get()"," ","-// Find duplicate upload attempts","+// Find duplicate uploads"," const duplicates = await db","   .collection('teams').doc(teamId)","   .collection('upload_logs')"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"2e630be8-96f7-465b-a43b-0ee6d8a6b18a","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","message":{"id":"msg_01PnMd9bUjGDKfCuXpBjdpKE","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01FntHmh2XHW9t6rfyr8bfaC","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","old_string":"- [ ] Upload attempt logging","new_string":"- [ ] Upload logging"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":291,"cache_read_input_tokens":34864,"cache_creation":{"ephemeral_5m_input_tokens":291,"ephemeral_1h_input_tokens":0},"output_tokens":123,"service_tier":"standard"}},"requestId":"req_011CSKHV5rvU6Cz9JZPC8yPZ","type":"assistant","uuid":"84867890-1463-4e3f-b8a6-2f56d17d03e9","timestamp":"2025-08-20T16:34:19.108Z"}
{"parentUuid":"84867890-1463-4e3f-b8a6-2f56d17d03e9","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FntHmh2XHW9t6rfyr8bfaC","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   376→### Phase 1: Core Upload (Week 1)\n   377→- [ ] SHA-256 calculation\n   378→- [ ] Basic upload to matter folders\n   379→- [ ] Document reference creation\n   380→- [ ] Upload logging\n   381→- [ ] Create system matters (general, client-general)\n   382→\n   383→### Phase 2: Search & Retrieval (Week 2)\n   384→- [ ] Document search by name/tags"}]},"uuid":"c65567f8-8a8a-4efa-87f4-16317b903d61","timestamp":"2025-08-20T16:34:19.167Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Coryphaeus\\docs\\firebase-storage-plan.md","oldString":"- [ ] Upload attempt logging","newString":"- [ ] Upload logging","originalFile":"# Simplified Firebase Storage Plan (KISS Edition)\n\n## Overview\n\n**Core Simplification**: ALL files go through matters. No exceptions.\n\nThis eliminates confusion about where files belong and simplifies security rules. Teams that need general storage simply create a \"General\" matter for non-client documents.\n\n**Key Principles:**\n- One storage pattern to rule them all: `/teams/{teamId}/matters/{matterId}/{sha256}.{ext}`\n- Every upload attempt is logged (successful or duplicate)\n- Simple, consistent security rules\n- Clear audit trail for compliance\n- Handles multi-client matters and pre-matter intake documents\n\n## Naming Conventions\n\nTo keep things organized and queryable:\n- **Team general**: `matter-general`\n- **Client intake**: `matter-client-{clientId}-general`  \n- **Regular matters**: `matter-{clientId}-{sequentialNumber}` or custom IDs\n- **Multi-client matters**: Use primary client or descriptive ID like `matter-smith-estate-001`\n\n## Storage Structure (Simplified)\n\n```\nFirebase Storage Root\n└── /teams/{teamId}/matters/{matterId}/{sha256}.{ext}\n```\n\nThat's it. One pattern. Every file follows this structure.\n\n### Special System Matters\n\nEach team automatically gets these special matters:\n- `matter-general` - Team resources, templates, non-client documents\n- `matter-archive` - Archived/inactive documents\n\n### Client Intake Matters\n\nEach client gets a special intake matter for pre-matter documents:\n- `matter-client-{clientId}-general` - Documents before matter is opened, or spanning multiple matters\n\nExample: Client ABC Corp would have:\n- `matter-client-abc-general` - Initial consultations, general corporate docs\n- `matter-abc-001` - Specific matter #1 (contract review)\n- `matter-abc-002` - Specific matter #2 (litigation)\n\n### Multi-Client Matters\n\nMatters can have multiple clients (stored in Firestore):\n```javascript\n// In Firestore: /teams/{teamId}/matters/{matterId}\n{\n  matterId: 'matter-smith-estate-001',\n  title: 'Smith Estate Planning',\n  clients: [\n    { clientId: 'client-john-smith', name: 'John Smith', role: 'primary' },\n    { clientId: 'client-jane-smith', name: 'Jane Smith', role: 'primary' }\n  ],\n  status: 'active'\n}\n\n## File Storage Implementation\n\n### 1. Upload Service (Simple & Complete)\n\n```javascript\nclass StorageService {\n  async uploadFile(file, teamId, matterId, metadata = {}) {\n    // 1. Calculate hash\n    const fileHash = await this.calculateSHA256(file)\n    const extension = file.name.split('.').pop().toLowerCase()\n    const fileName = `${fileHash}.${extension}`\n    const storagePath = `teams/${teamId}/matters/${matterId}/${fileName}`\n    \n    // 2. Create upload log record (ALWAYS, even for duplicates)\n    const logId = await this.logUploadAttempt({\n      teamId,\n      matterId,\n      fileName: file.name,\n      fileHash,\n      storagePath,\n      fileSize: file.size,\n      mimeType: file.type,\n      metadata,\n      uploadedBy: auth.currentUser.uid,\n      loggedAt: new Date()\n    })\n    \n    // 3. Check if file exists\n    const fileRef = storage.ref(storagePath)\n    const exists = await this.checkFileExists(fileRef)\n    \n    if (exists) {\n      // 4a. File exists - just create a reference\n      await this.createFileReference({\n        ...metadata,\n        fileHash,\n        storagePath,\n        isDuplicate: true,\n        originalUploadLogId: logId\n      })\n      \n      return { \n        success: true, \n        isDuplicate: true,\n        storagePath,\n        logId\n      }\n    }\n    \n    // 4b. New file - upload it\n    await fileRef.put(file)\n    \n    // 5. Create file reference\n    const docId = await this.createFileReference({\n      ...metadata,\n      fileHash,\n      storagePath,\n      isDuplicate: false,\n      originalUploadAttemptId: attemptId\n    })\n    \n    return { \n      success: true, \n      isDuplicate: false,\n      storagePath,\n      documentId: docId,\n      attemptId\n    }\n  }\n  \n  async calculateSHA256(file) {\n    const buffer = await file.arrayBuffer()\n    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n}\n```\n\n### 2. Firestore Collections (Simplified)\n\n#### Main Document Registry: `/teams/{teamId}/documents/{documentId}`\n```javascript\n{\n  // Core identifiers\n  fileHash: 'abc123...',           // SHA-256 hash\n  storagePath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // User-friendly info\n  displayName: 'Contract_2024.pdf', // What users see\n  originalFileName: 'Contract ABC Corp.pdf',\n  \n  // Organization\n  matterId: 'matter-123',\n  clientIds: ['client-456', 'client-789'],  // Array for multi-client matters\n  \n  // Metadata\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  uploadedBy: 'user-123',\n  uploadedAt: Timestamp,\n  \n  // Simple categorization\n  tags: ['contract', 'draft'],     // Simple array of tags\n  documentType: 'client-provided'  // 'client-provided', 'firm-generated', 'court-filing', 'correspondence'\n}\n```\n\n#### Upload Logs: `/teams/{teamId}/upload_logs/{logId}`\n```javascript\n{\n  // What was attempted\n  fileName: 'Contract ABC Corp.pdf',\n  fileHash: 'abc123...',\n  fileSize: 1048576,\n  mimeType: 'application/pdf',\n  \n  // Where it was going\n  matterId: 'matter-123',\n  targetPath: 'teams/xyz/matters/m123/abc123.pdf',\n  \n  // Who and when\n  uploadedBy: 'user-123',\n  loggedAt: Timestamp,\n  \n  // Result\n  wasSuccessful: true,              // false if error\n  wasDuplicate: false,              // true if file already existed\n  error: null,                      // Error message if failed\n  \n  // User metadata from upload\n  userMetadata: {\n    notes: 'Initial draft version'\n  }\n}\n```\n\n## Security Rules (Dead Simple)\n\n```javascript\nrules_version = '2';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // One rule: Team members can access their team's files\n    match /teams/{teamId}/matters/{matterId}/{fileName} {\n      allow read, write: if request.auth != null && \n                           request.auth.token.teamId == teamId;\n    }\n  }\n}\n```\n\n## Firestore Security Rules\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Team members can read all team documents and upload logs\n    match /teams/{teamId}/documents/{doc} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Documents are immutable\n    }\n    \n    match /teams/{teamId}/upload_logs/{log} {\n      allow read: if request.auth != null && \n                     request.auth.token.teamId == teamId;\n      allow create: if request.auth != null && \n                       request.auth.token.teamId == teamId;\n      allow update, delete: if false;  // Logs are immutable\n    }\n  }\n}\n```\n\n## Client Isolation Strategy\n\n### Matter-Based Isolation\nSince ALL files go through matters, client isolation is automatic:\n- Client A intake → `matter-client-A-general`\n- Client B intake → `matter-client-B-general`\n- Joint clients → `matter-smith-estate-001` (both clients listed)\n- Team files → `matter-general`\n\n### Multi-Client Considerations\nWhen matters have multiple clients (e.g., husband & wife):\n1. **Documents are associated with the matter**, not individual clients\n2. **All clients of a matter can access that matter's documents**\n3. **Client intake folders remain separate** until formally combined in a matter\n\nExample workflow:\n```javascript\n// John Smith uploads documents during initial consultation\nuploadFile(file, teamId, 'matter-client-john-general')\n\n// Jane Smith uploads documents during her consultation  \nuploadFile(file, teamId, 'matter-client-jane-general')\n\n// Lawyer opens joint matter for estate planning\ncreateMatter('matter-smith-estate-001', {\n  clients: ['client-john-smith', 'client-jane-smith']\n})\n\n// New documents go to the joint matter\nuploadFile(file, teamId, 'matter-smith-estate-001')\n\n// Optional: Associate intake documents with new matter\nassociateDocumentWithMatter(docId, 'matter-client-john-general', 'matter-smith-estate-001')\n```\n\n### Security Benefits\n1. **Pre-matter isolation**: Intake documents are isolated until matter is formalized\n2. **Clear boundaries**: Each matter is a clear security boundary\n3. **No accidents**: Can't accidentally mix different clients' matters\n4. **Audit trail**: Document associations are tracked\n```\n\n## Tracking & Audit Trail\n\n### Every Upload is Logged\n```javascript\n// Example: User uploads same file 3 times to different matters\n// Result: 1 file in storage, 3 upload_logs records\n\n// Log 1: New file to matter-123\n{\n  logId: 'log-001',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-123',\n  wasDuplicate: false,  // First upload\n  wasSuccessful: true\n}\n\n// Log 2: Same file to matter-456\n{\n  logId: 'log-002',\n  fileName: 'Contract_Final.pdf',  // Different name, same content\n  fileHash: 'abc123',              // Same hash!\n  matterId: 'matter-456',\n  wasDuplicate: true,               // Detected duplicate\n  wasSuccessful: true\n}\n\n// Log 3: Upload failed (network error)\n{\n  logId: 'log-003',\n  fileName: 'Contract.pdf',\n  fileHash: 'abc123',\n  matterId: 'matter-789',\n  wasDuplicate: true,\n  wasSuccessful: false,\n  error: 'Network timeout'\n}\n```\n\n### Useful Queries\n\n```javascript\n// Find all documents for a specific client (across all matters)\nconst clientDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('clientIds', 'array-contains', clientId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find intake documents for a client (pre-matter)\nconst intakeDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', `matter-client-${clientId}-general`)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n\n// Find all uploads by a user\nconst userUploads = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')\n  .where('uploadedBy', '==', userId)\n  .orderBy('loggedAt', 'desc')\n  .get()\n\n// Find duplicate uploads\nconst duplicates = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')\n  .where('wasDuplicate', '==', true)\n  .get()\n\n// Get upload history for a specific file hash\nconst fileHistory = await db\n  .collection('teams').doc(teamId)\n  .collection('upload_logs')\n  .where('fileHash', '==', fileHash)\n  .orderBy('loggedAt', 'desc')\n  .get()\n\n// Find all documents for a multi-client matter\nconst matterDocs = await db\n  .collection('teams').doc(teamId)\n  .collection('documents')\n  .where('matterId', '==', matterId)\n  .orderBy('uploadedAt', 'desc')\n  .get()\n```\n\n## Implementation Phases\n\n### Phase 1: Core Upload (Week 1)\n- [ ] SHA-256 calculation\n- [ ] Basic upload to matter folders\n- [ ] Document reference creation\n- [ ] Upload attempt logging\n- [ ] Create system matters (general, client-general)\n\n### Phase 2: Search & Retrieval (Week 2)\n- [ ] Document search by name/tags\n- [ ] Client document aggregation across matters\n- [ ] Download functionality\n- [ ] Upload history viewing\n\n### Phase 3: Nice-to-haves (If needed)\n- [ ] Bulk upload\n- [ ] File preview\n- [ ] Document association between matters\n- [ ] Intake-to-matter workflow automation\n\n## Practical Workflows\n\n### New Client Consultation Flow\n```javascript\n// 1. Client calls for consultation\nconst clientId = await createClient({\n  name: 'John Smith',\n  email: 'john@example.com'\n})\n\n// 2. System auto-creates intake matter\nconst intakeMatterId = `matter-client-${clientId}-general`\n\n// 3. Upload consultation documents\nawait uploadFile(consulationNotes, teamId, intakeMatterId)\nawait uploadFile(clientProvidedDocs, teamId, intakeMatterId)\n\n// 4. If client engages firm, create formal matter\nconst formalMatterId = await createMatter({\n  id: 'matter-smith-divorce-001',\n  clients: [clientId],\n  type: 'divorce'\n})\n\n// 5. New documents go to formal matter\nawait uploadFile(retainerAgreement, teamId, formalMatterId)\n\n// 6. Optionally associate intake docs with formal matter\n// (creates references, doesn't move files)\n```\n\n### Joint Client Matter Flow\n```javascript\n// 1. Create both clients\nconst husbandId = await createClient({ name: 'John Smith' })\nconst wifeId = await createClient({ name: 'Jane Smith' })\n\n// 2. Each may have individual intake documents\nawait uploadFile(husbandTaxReturn, teamId, `matter-client-${husbandId}-general`)\nawait uploadFile(wifeFinancials, teamId, `matter-client-${wifeId}-general`)\n\n// 3. Create joint matter\nconst jointMatterId = await createMatter({\n  id: 'matter-smith-estate-001',\n  clients: [husbandId, wifeId],\n  type: 'estate-planning'\n})\n\n// 4. Joint documents go to joint matter\nawait uploadFile(jointAssets, teamId, jointMatterId)\n```\n\n## Migration Path for Existing Files\n\nIf you already have files in Firebase Storage:\n\n```javascript\nasync function migrateToMatterStructure() {\n  // 1. Create system matters\n  await createSystemMatters(teamId)\n  \n  // 2. Create client intake matters for existing clients\n  const clients = await getExistingClients()\n  for (const client of clients) {\n    await createMatter({\n      id: `matter-client-${client.id}-general`,\n      name: `${client.name} - Intake Documents`,\n      isSystemMatter: true,\n      clients: [client.id]\n    })\n  }\n  \n  // 3. Map existing files to appropriate matters\n  // Team files → matter-general\n  // Client files without matter → matter-client-{id}-general\n  // Client files with matter → keep in existing matter\n  \n  // 4. Update Firestore document references\n  // 5. Clean up old structure (after verification)\n}\n\nasync function createSystemMatters(teamId) {\n  // Create team general matter\n  await createMatter({\n    id: 'matter-general',\n    name: 'General Team Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n  \n  // Create archive matter\n  await createMatter({\n    id: 'matter-archive',\n    name: 'Archived Documents',\n    isSystemMatter: true,\n    clients: []\n  })\n}\n```\n\n## Benefits of This Simplified Approach\n\n1. **One Pattern**: Developers only learn one file path pattern\n2. **Consistent Security**: Same rules apply to all files\n3. **Natural Isolation**: Matter-based structure naturally isolates clients\n4. **Complete Audit Trail**: Every upload attempt is logged\n5. **Efficient Storage**: SHA-256 deduplication still works perfectly\n6. **Simple Queries**: Flat structure makes queries straightforward\n7. **Future-Proof**: Can add features without changing core structure\n\n## What We Removed (YAGNI)\n\n- ❌ Complex three-tier structure (system/team/matter)\n- ❌ Multiple storage patterns to remember\n- ❌ Versioning system (add later if needed)\n- ❌ Complex metadata (keep it flat)\n- ❌ System files folder (use matter-general instead)\n\n## Common Operations\n\n```javascript\n// Upload initial consultation documents (no matter yet)\nawait storageService.uploadFile(\n  file, \n  teamId, \n  'matter-client-abc-general',  // Client's general intake folder\n  { \n    displayName: 'Initial Tax Returns',\n    clientIds: ['client-abc'],\n    tags: ['intake', 'tax'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload to a multi-client matter (husband & wife)\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-smith-estate-001',\n  {\n    displayName: 'Joint Asset Declaration',\n    clientIds: ['client-john-smith', 'client-jane-smith'],\n    tags: ['estate', 'assets'],\n    documentType: 'client-provided'\n  }\n)\n\n// Upload a team resource\nawait storageService.uploadFile(\n  file,\n  teamId,\n  'matter-general',  // Team's general matter\n  {\n    displayName: 'Team Handbook 2024',\n    clientIds: [],  // No clients for team documents\n    tags: ['handbook', 'policy'],\n    documentType: 'firm-generated'\n  }\n)\n\n// Move document reference from intake to formal matter (just update Firestore)\nasync function associateDocumentWithMatter(documentId, fromMatterId, toMatterId) {\n  // Note: File stays in original location (no need to move in Storage)\n  // Just create a new document reference pointing to same file\n  const doc = await db\n    .collection('teams').doc(teamId)\n    .collection('documents').doc(documentId)\n    .get()\n  \n  // Create new reference for the formal matter\n  await db\n    .collection('teams').doc(teamId)\n    .collection('documents').add({\n      ...doc.data(),\n      matterId: toMatterId,\n      associatedFrom: fromMatterId,\n      associatedAt: new Date(),\n      notes: 'Moved from client intake to formal matter'\n    })\n}\n```\n\n## Required Indexes (Minimal)\n\n```javascript\n// Just the essentials\n[\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'matterId', order: 'ASCENDING' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/documents',\n    fields: [\n      { field: 'clientIds', mode: 'ARRAY_CONTAINS' },\n      { field: 'uploadedAt', order: 'DESCENDING' }\n    ]\n  },\n  {\n    collection: 'teams/{teamId}/upload_attempts',\n    fields: [\n      { field: 'uploadedBy', order: 'ASCENDING' },\n      { field: 'attemptedAt', order: 'DESCENDING' }\n    ]\n  }\n]\n```\n\nRemember: **Start simple, add complexity only when real usage patterns demand it.**","structuredPatch":[{"oldStart":377,"oldLines":7,"newStart":377,"newLines":7,"lines":[" - [ ] SHA-256 calculation"," - [ ] Basic upload to matter folders"," - [ ] Document reference creation","-- [ ] Upload attempt logging","+- [ ] Upload logging"," - [ ] Create system matters (general, client-general)"," "," ### Phase 2: Search & Retrieval (Week 2)"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"c65567f8-8a8a-4efa-87f4-16317b903d61","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Coryphaeus","sessionId":"d4d2cf01-2c90-43b8-81b6-863dbda70e25","version":"1.0.85","gitBranch":"main","type":"user","message":{"role":"user","content":[{"type":"text","text":"[Request interrupted by user]"}]},"uuid":"e77fd686-44a3-4f93-9956-d59c3e8586c9","timestamp":"2025-08-20T16:34:20.964Z"}

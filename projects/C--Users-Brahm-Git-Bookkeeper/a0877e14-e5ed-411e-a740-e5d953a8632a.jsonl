{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","type":"user","message":{"role":"user","content":"Given that we have deleted all data and couments, we should update:  docs\\data-structures\\evidence-v1.1-schema.md\\\\                                           │   \\                                                                                                                                                     Since we are now starting from a clean slate.  "},"uuid":"222a41e2-c1fa-4da2-9ddb-989d14e04ac3","timestamp":"2025-08-31T05:59:19.090Z"}
{"parentUuid":"222a41e2-c1fa-4da2-9ddb-989d14e04ac3","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01E5Ep28Rx7rsVqPcYgJ5Rfy","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"I'll update the evidence schema documentation to reflect the clean slate state. Let me first read the current file to understand what needs to be updated."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":5847,"cache_read_input_tokens":17005,"cache_creation":{"ephemeral_5m_input_tokens":5847,"ephemeral_1h_input_tokens":0},"output_tokens":112,"service_tier":"standard"}},"requestId":"req_011CSfGxzM2CAGeEnTuvRLcT","type":"assistant","uuid":"984fbf6d-4e23-4021-b053-9be2ab3f1896","timestamp":"2025-08-31T05:59:24.011Z"}
{"parentUuid":"984fbf6d-4e23-4021-b053-9be2ab3f1896","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01E5Ep28Rx7rsVqPcYgJ5Rfy","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01Kmr7JusHY4wPa7Fhho1zne","name":"Read","input":{"file_path":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":5847,"cache_read_input_tokens":17005,"cache_creation":{"ephemeral_5m_input_tokens":5847,"ephemeral_1h_input_tokens":0},"output_tokens":112,"service_tier":"standard"}},"requestId":"req_011CSfGxzM2CAGeEnTuvRLcT","type":"assistant","uuid":"bab35e9c-80f7-470d-bead-c8a497fe39af","timestamp":"2025-08-31T05:59:24.046Z"}
{"parentUuid":"bab35e9c-80f7-470d-bead-c8a497fe39af","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Kmr7JusHY4wPa7Fhho1zne","type":"tool_result","content":"     1→# Evidence Document Structure v1.1 - Category-Based Tags\n     2→\n     3→## Overview\n     4→\n     5→This document defines the updated Evidence document structure for Organizer v1.1, which introduces structured category-based tagging while maintaining full backward compatibility with v1.0.\n     6→\n     7→## Database Location\n     8→```\n     9→/teams/{teamId}/evidence/{evidenceId}\n    10→```\n    11→\n    12→## Updated Evidence Document Structure\n    13→\n    14→### Current v1.0 Structure (Preserved)\n    15→```javascript\n    16→{\n    17→  // === FILE REFERENCES (Unchanged) ===\n    18→  storageRef: {\n    19→    storage: 'uploads',\n    20→    fileHash: string  // SHA-256 hash of file content\n    21→  },\n    22→  \n    23→  displayCopy: {\n    24→    metadataHash: string,  // Reference to originalMetadata document\n    25→    folderPath: string     // Original folder path from upload\n    26→  },\n    27→  \n    28→  // === FILE PROPERTIES (Unchanged) ===\n    29→  fileSize: number,\n    30→  \n    31→  // === PROCESSING STATUS (Unchanged) ===\n    32→  isProcessed: boolean,\n    33→  hasAllPages: boolean | null,\n    34→  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n    35→  \n    36→  // === LEGACY TAGS (Preserved for Compatibility) ===\n    37→  tags: string[],           // v1.0 free-form tags - PRESERVED\n    38→  tagCount: number,         // Total count of all tags\n    39→  lastTaggedAt: timestamp,\n    40→  taggedBy: 'manual' | 'ai' | 'migration',\n    41→  \n    42→  // === TIMESTAMPS (Unchanged) ===\n    43→  updatedAt: timestamp\n    44→}\n    45→```\n    46→\n    47→### New v1.1 Structured Tags\n    48→```javascript\n    49→{\n    50→  // === NEW STRUCTURED TAGS ===\n    51→  tagsByHuman: [            // Human-assigned structured tags\n    52→    {\n    53→      categoryId: string,      // Reference to category document ID\n    54→      categoryName: string,    // Denormalized category name for performance\n    55→      tagId: string,          // Unique identifier for this tag instance\n    56→      tagName: string,        // Display name of the tag\n    57→      color: string          // Hex color code (e.g., '#1976d2')\n    58→    }\n    59→  ],\n    60→  \n    61→  tagsByAI: [               // AI-assigned structured tags (v1.2 preparation)\n    62→    {\n    63→      categoryId: string,\n    64→      categoryName: string,\n    65→      tagId: string,\n    66→      tagName: string,\n    67→      color: string,\n    68→      confidence: number     // AI confidence score (0.0 - 1.0)\n    69→    }\n    70→  ],\n    71→  \n    72→  // === MIGRATION SUPPORT ===\n    73→  legacyTags: string[],     // Explicit storage of original v1.0 tags\n    74→  migrationStatus: 'pending' | 'completed' | 'skipped',\n    75→  migratedAt: timestamp,    // When migration was performed\n    76→  \n    77→  // === UPDATED COMPUTED FIELDS ===\n    78→  tagCount: number         // Total: tagsByHuman.length + tagsByAI.length + legacyTags.length\n    79→}\n    80→```\n    81→\n    82→## Complete v1.1 Evidence Document Schema\n    83→\n    84→```javascript\n    85→{\n    86→  // === FILE REFERENCES ===\n    87→  storageRef: {\n    88→    storage: 'uploads',\n    89→    fileHash: string\n    90→  },\n    91→  \n    92→  displayCopy: {\n    93→    metadataHash: string,\n    94→    folderPath: string\n    95→  },\n    96→  \n    97→  // === FILE PROPERTIES ===\n    98→  fileSize: number,\n    99→  \n   100→  // === PROCESSING STATUS ===\n   101→  isProcessed: boolean,\n   102→  hasAllPages: boolean | null,\n   103→  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n   104→  \n   105→  // === STRUCTURED TAGGING SYSTEM (v1.1) ===\n   106→  tagsByHuman: [\n   107→    {\n   108→      categoryId: string,\n   109→      categoryName: string,\n   110→      tagId: string,\n   111→      tagName: string,\n   112→      color: string\n   113→    }\n   114→  ],\n   115→  \n   116→  tagsByAI: [\n   117→    {\n   118→      categoryId: string,\n   119→      categoryName: string,\n   120→      tagId: string,\n   121→      tagName: string,\n   122→      color: string,\n   123→      confidence: number\n   124→    }\n   125→  ],\n   126→  \n   127→  // === BACKWARD COMPATIBILITY ===\n   128→  tags: string[],              // v1.0 tags - preserved for compatibility\n   129→  legacyTags: string[],        // Explicit legacy tag storage\n   130→  \n   131→  // === METADATA ===\n   132→  tagCount: number,            // Total count of all tags\n   133→  lastTaggedAt: timestamp,\n   134→  taggedBy: 'manual' | 'ai' | 'migration',\n   135→  migrationStatus: 'pending' | 'completed' | 'skipped',\n   136→  migratedAt: timestamp,\n   137→  \n   138→  // === TIMESTAMPS ===\n   139→  updatedAt: timestamp\n   140→}\n   141→```\n   142→\n   143→## Migration Strategy\n   144→\n   145→### Phase 1: Non-Breaking Schema Extension\n   146→1. **Add new fields** without removing existing fields\n   147→2. **Preserve `tags` array** for v1.0 compatibility  \n   148→3. **Add `legacyTags` array** for explicit legacy storage\n   149→4. **Initialize structured arrays** as empty (`tagsByHuman: [], tagsByAI: []`)\n   150→\n   151→### Phase 2: Data Population  \n   152→1. **Copy `tags` to `legacyTags`** for all existing documents\n   153→2. **User-initiated migration** converts legacy tags to structured format\n   154→3. **Preserve original `tags` array** until user confirms migration\n   155→\n   156→### Phase 3: Gradual Transition\n   157→1. **New tags** created using structured format\n   158→2. **Search** includes both structured and legacy tags\n   159→3. **Display** prioritizes structured tags, falls back to legacy\n   160→\n   161→## Validation Rules\n   162→\n   163→### Structured Tag Validation\n   164→```javascript\n   165→// tagsByHuman and tagsByAI validation\n   166→{\n   167→  categoryId: {\n   168→    required: true,\n   169→    type: 'string',\n   170→    pattern: /^[a-zA-Z0-9_-]+$/ // Valid Firestore document ID\n   171→  },\n   172→  categoryName: {\n   173→    required: true,\n   174→    type: 'string',\n   175→    maxLength: 50\n   176→  },\n   177→  tagId: {\n   178→    required: true,\n   179→    type: 'string',\n   180→    format: 'uuid' // Generated using crypto.randomUUID()\n   181→  },\n   182→  tagName: {\n   183→    required: true,\n   184→    type: 'string',\n   185→    maxLength: 30\n   186→  },\n   187→  color: {\n   188→    required: true,\n   189→    type: 'string',\n   190→    pattern: /^#[0-9A-Fa-f]{6}$/ // Valid hex color\n   191→  },\n   192→  confidence: { // AI tags only\n   193→    type: 'number',\n   194→    minimum: 0.0,\n   195→    maximum: 1.0\n   196→  }\n   197→}\n   198→```\n   199→\n   200→### Document-Level Constraints\n   201→- **Maximum 100 structured tags per document** (tagsByHuman + tagsByAI)\n   202→- **Maximum 50 tags per category** per document\n   203→- **Category must exist** and be active when adding structured tags\n   204→- **Tag names within category must be unique** per document\n   205→\n   206→## Firestore Security Rules\n   207→\n   208→### Updated Rules for v1.1\n   209→```javascript\n   210→// Evidence document access\n   211→match /teams/{teamId}/evidence/{evidenceId} {\n   212→  allow read, write: if \n   213→    request.auth != null &&\n   214→    resource.data.get('teamId', teamId) == teamId &&\n   215→    isTeamMember(teamId);\n   216→  \n   217→  // Validate structured tags on write\n   218→  allow update: if\n   219→    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n   220→    validateStructuredTags(request.resource.data.get('tagsByAI', [])) &&\n   221→    preserveLegacyTags(resource.data, request.resource.data);\n   222→}\n   223→\n   224→function validateStructuredTags(tags) {\n   225→  return tags.size() <= 100 &&\n   226→    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n   227→}\n   228→\n   229→function preserveLegacyTags(oldData, newData) {\n   230→  // Ensure legacyTags are not deleted during updates\n   231→  return newData.get('legacyTags', []).hasAll(oldData.get('legacyTags', []));\n   232→}\n   233→```\n   234→\n   235→## Query Patterns\n   236→\n   237→### Search Across All Tag Types\n   238→```javascript\n   239→// Client-side filtering for mixed tag search\n   240→const searchTerm = 'invoice';\n   241→\n   242→evidence.filter(doc => {\n   243→  // Search structured tags\n   244→  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n   245→  const hasStructuredMatch = structuredTags.some(tag => \n   246→    tag.tagName.toLowerCase().includes(searchTerm) ||\n   247→    tag.categoryName.toLowerCase().includes(searchTerm)\n   248→  );\n   249→  \n   250→  // Search legacy tags\n   251→  const hasLegacyMatch = (doc.legacyTags || doc.tags || [])\n   252→    .some(tag => tag.toLowerCase().includes(searchTerm));\n   253→    \n   254→  return hasStructuredMatch || hasLegacyMatch;\n   255→});\n   256→```\n   257→\n   258→### Category-Based Filtering\n   259→```javascript\n   260→// Filter by specific category and tags\n   261→const categoryFilters = {\n   262→  'cat-doc-type': ['Invoice', 'Statement'],\n   263→  'cat-institution': ['Bank of America']\n   264→};\n   265→\n   266→evidence.filter(doc => {\n   267→  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n   268→  \n   269→  return Object.entries(categoryFilters).every(([categoryId, selectedTags]) => {\n   270→    return structuredTags.some(tag => \n   271→      tag.categoryId === categoryId && \n   272→      selectedTags.includes(tag.tagName)\n   273→    );\n   274→  });\n   275→});\n   276→```\n   277→\n   278→## Performance Considerations\n   279→\n   280→### Indexing Strategy\n   281→```javascript\n   282→// Composite indexes for efficient queries\n   283→[\n   284→  ['tagsByHuman.categoryId', 'updatedAt'],\n   285→  ['tagsByHuman.tagName', 'updatedAt'],\n   286→  ['tagsByAI.categoryId', 'confidence', 'updatedAt']\n   287→]\n   288→```\n   289→\n   290→### Denormalization Benefits\n   291→- **Category names** stored in each tag for fast display\n   292→- **Colors** stored in tags to avoid category lookups\n   293→- **Tag counts** computed and stored for quick statistics\n   294→\n   295→### Memory Management\n   296→- **Lazy loading** of tag details when needed\n   297→- **Pagination** for documents with many tags\n   298→- **Caching** of frequently accessed category data\n   299→\n   300→## Rollback Plan\n   301→\n   302→### Emergency Rollback to v1.0\n   303→1. **Revert components** to use `tags` array only\n   304→2. **Disable structured tag features** via feature flags\n   305→3. **Preserve all data** - no data loss during rollback\n   306→4. **Migration can resume** when issues are resolved\n   307→\n   308→### Rollback Implementation\n   309→```javascript\n   310→// Feature flag for emergency rollback\n   311→const USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n   312→\n   313→// Fallback tag display\n   314→const getDisplayTags = (evidence) => {\n   315→  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n   316→    return evidence.tagsByHuman.map(tag => tag.tagName);\n   317→  }\n   318→  return evidence.legacyTags || evidence.tags || [];\n   319→};\n   320→```\n   321→\n   322→## Testing Requirements\n   323→\n   324→### Unit Tests\n   325→- [ ] Structured tag validation\n   326→- [ ] Migration utilities  \n   327→- [ ] Search across mixed tag types\n   328→- [ ] Category-based filtering\n   329→\n   330→### Integration Tests\n   331→- [ ] Evidence creation with structured tags\n   332→- [ ] Legacy tag preservation during updates\n   333→- [ ] Migration from v1.0 to v1.1 format\n   334→- [ ] Rollback to v1.0 compatibility\n   335→\n   336→### Performance Tests\n   337→- [ ] Query performance with 1000+ documents\n   338→- [ ] Tag assignment operations <500ms\n   339→- [ ] Search response time <300ms with mixed tags\n   340→- [ ] Memory usage with large tag datasets\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"90243366-7ca2-4b75-9309-b327c22b90d5","timestamp":"2025-08-31T05:59:24.077Z","toolUseResult":{"type":"text","file":{"filePath":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","content":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the updated Evidence document structure for Organizer v1.1, which introduces structured category-based tagging while maintaining full backward compatibility with v1.0.\n\n## Database Location\n```\n/teams/{teamId}/evidence/{evidenceId}\n```\n\n## Updated Evidence Document Structure\n\n### Current v1.0 Structure (Preserved)\n```javascript\n{\n  // === FILE REFERENCES (Unchanged) ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES (Unchanged) ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS (Unchanged) ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === LEGACY TAGS (Preserved for Compatibility) ===\n  tags: string[],           // v1.0 free-form tags - PRESERVED\n  tagCount: number,         // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai' | 'migration',\n  \n  // === TIMESTAMPS (Unchanged) ===\n  updatedAt: timestamp\n}\n```\n\n### New v1.1 Structured Tags\n```javascript\n{\n  // === NEW STRUCTURED TAGS ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (v1.2 preparation)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === MIGRATION SUPPORT ===\n  legacyTags: string[],     // Explicit storage of original v1.0 tags\n  migrationStatus: 'pending' | 'completed' | 'skipped',\n  migratedAt: timestamp,    // When migration was performed\n  \n  // === UPDATED COMPUTED FIELDS ===\n  tagCount: number         // Total: tagsByHuman.length + tagsByAI.length + legacyTags.length\n}\n```\n\n## Complete v1.1 Evidence Document Schema\n\n```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string\n  },\n  \n  displayCopy: {\n    metadataHash: string,\n    folderPath: string\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM (v1.1) ===\n  tagsByHuman: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string\n    }\n  ],\n  \n  tagsByAI: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number\n    }\n  ],\n  \n  // === BACKWARD COMPATIBILITY ===\n  tags: string[],              // v1.0 tags - preserved for compatibility\n  legacyTags: string[],        // Explicit legacy tag storage\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai' | 'migration',\n  migrationStatus: 'pending' | 'completed' | 'skipped',\n  migratedAt: timestamp,\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```\n\n## Migration Strategy\n\n### Phase 1: Non-Breaking Schema Extension\n1. **Add new fields** without removing existing fields\n2. **Preserve `tags` array** for v1.0 compatibility  \n3. **Add `legacyTags` array** for explicit legacy storage\n4. **Initialize structured arrays** as empty (`tagsByHuman: [], tagsByAI: []`)\n\n### Phase 2: Data Population  \n1. **Copy `tags` to `legacyTags`** for all existing documents\n2. **User-initiated migration** converts legacy tags to structured format\n3. **Preserve original `tags` array** until user confirms migration\n\n### Phase 3: Gradual Transition\n1. **New tags** created using structured format\n2. **Search** includes both structured and legacy tags\n3. **Display** prioritizes structured tags, falls back to legacy\n\n## Validation Rules\n\n### Structured Tag Validation\n```javascript\n// tagsByHuman and tagsByAI validation\n{\n  categoryId: {\n    required: true,\n    type: 'string',\n    pattern: /^[a-zA-Z0-9_-]+$/ // Valid Firestore document ID\n  },\n  categoryName: {\n    required: true,\n    type: 'string',\n    maxLength: 50\n  },\n  tagId: {\n    required: true,\n    type: 'string',\n    format: 'uuid' // Generated using crypto.randomUUID()\n  },\n  tagName: {\n    required: true,\n    type: 'string',\n    maxLength: 30\n  },\n  color: {\n    required: true,\n    type: 'string',\n    pattern: /^#[0-9A-Fa-f]{6}$/ // Valid hex color\n  },\n  confidence: { // AI tags only\n    type: 'number',\n    minimum: 0.0,\n    maximum: 1.0\n  }\n}\n```\n\n### Document-Level Constraints\n- **Maximum 100 structured tags per document** (tagsByHuman + tagsByAI)\n- **Maximum 50 tags per category** per document\n- **Category must exist** and be active when adding structured tags\n- **Tag names within category must be unique** per document\n\n## Firestore Security Rules\n\n### Updated Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', [])) &&\n    preserveLegacyTags(resource.data, request.resource.data);\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n\nfunction preserveLegacyTags(oldData, newData) {\n  // Ensure legacyTags are not deleted during updates\n  return newData.get('legacyTags', []).hasAll(oldData.get('legacyTags', []));\n}\n```\n\n## Query Patterns\n\n### Search Across All Tag Types\n```javascript\n// Client-side filtering for mixed tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  const hasStructuredMatch = structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n  \n  // Search legacy tags\n  const hasLegacyMatch = (doc.legacyTags || doc.tags || [])\n    .some(tag => tag.toLowerCase().includes(searchTerm));\n    \n  return hasStructuredMatch || hasLegacyMatch;\n});\n```\n\n### Category-Based Filtering\n```javascript\n// Filter by specific category and tags\nconst categoryFilters = {\n  'cat-doc-type': ['Invoice', 'Statement'],\n  'cat-institution': ['Bank of America']\n};\n\nevidence.filter(doc => {\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  \n  return Object.entries(categoryFilters).every(([categoryId, selectedTags]) => {\n    return structuredTags.some(tag => \n      tag.categoryId === categoryId && \n      selectedTags.includes(tag.tagName)\n    );\n  });\n});\n```\n\n## Performance Considerations\n\n### Indexing Strategy\n```javascript\n// Composite indexes for efficient queries\n[\n  ['tagsByHuman.categoryId', 'updatedAt'],\n  ['tagsByHuman.tagName', 'updatedAt'],\n  ['tagsByAI.categoryId', 'confidence', 'updatedAt']\n]\n```\n\n### Denormalization Benefits\n- **Category names** stored in each tag for fast display\n- **Colors** stored in tags to avoid category lookups\n- **Tag counts** computed and stored for quick statistics\n\n### Memory Management\n- **Lazy loading** of tag details when needed\n- **Pagination** for documents with many tags\n- **Caching** of frequently accessed category data\n\n## Rollback Plan\n\n### Emergency Rollback to v1.0\n1. **Revert components** to use `tags` array only\n2. **Disable structured tag features** via feature flags\n3. **Preserve all data** - no data loss during rollback\n4. **Migration can resume** when issues are resolved\n\n### Rollback Implementation\n```javascript\n// Feature flag for emergency rollback\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Fallback tag display\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return evidence.legacyTags || evidence.tags || [];\n};\n```\n\n## Testing Requirements\n\n### Unit Tests\n- [ ] Structured tag validation\n- [ ] Migration utilities  \n- [ ] Search across mixed tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Legacy tag preservation during updates\n- [ ] Migration from v1.0 to v1.1 format\n- [ ] Rollback to v1.0 compatibility\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms with mixed tags\n- [ ] Memory usage with large tag datasets","numLines":340,"startLine":1,"totalLines":340}}}
{"parentUuid":"90243366-7ca2-4b75-9309-b327c22b90d5","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01Hp8JVzfeciAVwXfdE9XYn3","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now I'll update the evidence schema documentation to reflect that we're starting with a clean slate, removing references to existing data and migration concerns."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4118,"cache_read_input_tokens":22852,"cache_creation":{"ephemeral_5m_input_tokens":4118,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CSfGyMGMqdVKHQ53wy4pv","type":"assistant","uuid":"1de99b6b-026a-4435-9cbe-503b09baeebf","timestamp":"2025-08-31T05:59:28.310Z"}
{"parentUuid":"1de99b6b-026a-4435-9cbe-503b09baeebf","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01Hp8JVzfeciAVwXfdE9XYn3","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01XNSEkqMtzDEwuoU4WoMa8u","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","old_string":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the updated Evidence document structure for Organizer v1.1, which introduces structured category-based tagging while maintaining full backward compatibility with v1.0.","new_string":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the Evidence document structure for Organizer v1.1, featuring structured category-based tagging. Since we are starting with a clean slate (all data and documents have been deleted), this version will be the initial implementation without migration considerations."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4118,"cache_read_input_tokens":22852,"cache_creation":{"ephemeral_5m_input_tokens":4118,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CSfGyMGMqdVKHQ53wy4pv","type":"assistant","uuid":"274706b8-46f1-4d92-8efb-2d1064cbfe62","timestamp":"2025-08-31T05:59:31.214Z"}
{"parentUuid":"274706b8-46f1-4d92-8efb-2d1064cbfe62","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XNSEkqMtzDEwuoU4WoMa8u","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→# Evidence Document Structure v1.1 - Category-Based Tags\n     2→\n     3→## Overview\n     4→\n     5→This document defines the Evidence document structure for Organizer v1.1, featuring structured category-based tagging. Since we are starting with a clean slate (all data and documents have been deleted), this version will be the initial implementation without migration considerations.\n     6→\n     7→## Database Location\n     8→```\n     9→/teams/{teamId}/evidence/{evidenceId}"}]},"uuid":"674fffe9-24d8-4bbe-bdf9-a4586680741d","timestamp":"2025-08-31T05:59:45.667Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","oldString":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the updated Evidence document structure for Organizer v1.1, which introduces structured category-based tagging while maintaining full backward compatibility with v1.0.","newString":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the Evidence document structure for Organizer v1.1, featuring structured category-based tagging. Since we are starting with a clean slate (all data and documents have been deleted), this version will be the initial implementation without migration considerations.","originalFile":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the updated Evidence document structure for Organizer v1.1, which introduces structured category-based tagging while maintaining full backward compatibility with v1.0.\n\n## Database Location\n```\n/teams/{teamId}/evidence/{evidenceId}\n```\n\n## Updated Evidence Document Structure\n\n### Current v1.0 Structure (Preserved)\n```javascript\n{\n  // === FILE REFERENCES (Unchanged) ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES (Unchanged) ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS (Unchanged) ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === LEGACY TAGS (Preserved for Compatibility) ===\n  tags: string[],           // v1.0 free-form tags - PRESERVED\n  tagCount: number,         // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai' | 'migration',\n  \n  // === TIMESTAMPS (Unchanged) ===\n  updatedAt: timestamp\n}\n```\n\n### New v1.1 Structured Tags\n```javascript\n{\n  // === NEW STRUCTURED TAGS ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (v1.2 preparation)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === MIGRATION SUPPORT ===\n  legacyTags: string[],     // Explicit storage of original v1.0 tags\n  migrationStatus: 'pending' | 'completed' | 'skipped',\n  migratedAt: timestamp,    // When migration was performed\n  \n  // === UPDATED COMPUTED FIELDS ===\n  tagCount: number         // Total: tagsByHuman.length + tagsByAI.length + legacyTags.length\n}\n```\n\n## Complete v1.1 Evidence Document Schema\n\n```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string\n  },\n  \n  displayCopy: {\n    metadataHash: string,\n    folderPath: string\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM (v1.1) ===\n  tagsByHuman: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string\n    }\n  ],\n  \n  tagsByAI: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number\n    }\n  ],\n  \n  // === BACKWARD COMPATIBILITY ===\n  tags: string[],              // v1.0 tags - preserved for compatibility\n  legacyTags: string[],        // Explicit legacy tag storage\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai' | 'migration',\n  migrationStatus: 'pending' | 'completed' | 'skipped',\n  migratedAt: timestamp,\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```\n\n## Migration Strategy\n\n### Phase 1: Non-Breaking Schema Extension\n1. **Add new fields** without removing existing fields\n2. **Preserve `tags` array** for v1.0 compatibility  \n3. **Add `legacyTags` array** for explicit legacy storage\n4. **Initialize structured arrays** as empty (`tagsByHuman: [], tagsByAI: []`)\n\n### Phase 2: Data Population  \n1. **Copy `tags` to `legacyTags`** for all existing documents\n2. **User-initiated migration** converts legacy tags to structured format\n3. **Preserve original `tags` array** until user confirms migration\n\n### Phase 3: Gradual Transition\n1. **New tags** created using structured format\n2. **Search** includes both structured and legacy tags\n3. **Display** prioritizes structured tags, falls back to legacy\n\n## Validation Rules\n\n### Structured Tag Validation\n```javascript\n// tagsByHuman and tagsByAI validation\n{\n  categoryId: {\n    required: true,\n    type: 'string',\n    pattern: /^[a-zA-Z0-9_-]+$/ // Valid Firestore document ID\n  },\n  categoryName: {\n    required: true,\n    type: 'string',\n    maxLength: 50\n  },\n  tagId: {\n    required: true,\n    type: 'string',\n    format: 'uuid' // Generated using crypto.randomUUID()\n  },\n  tagName: {\n    required: true,\n    type: 'string',\n    maxLength: 30\n  },\n  color: {\n    required: true,\n    type: 'string',\n    pattern: /^#[0-9A-Fa-f]{6}$/ // Valid hex color\n  },\n  confidence: { // AI tags only\n    type: 'number',\n    minimum: 0.0,\n    maximum: 1.0\n  }\n}\n```\n\n### Document-Level Constraints\n- **Maximum 100 structured tags per document** (tagsByHuman + tagsByAI)\n- **Maximum 50 tags per category** per document\n- **Category must exist** and be active when adding structured tags\n- **Tag names within category must be unique** per document\n\n## Firestore Security Rules\n\n### Updated Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', [])) &&\n    preserveLegacyTags(resource.data, request.resource.data);\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n\nfunction preserveLegacyTags(oldData, newData) {\n  // Ensure legacyTags are not deleted during updates\n  return newData.get('legacyTags', []).hasAll(oldData.get('legacyTags', []));\n}\n```\n\n## Query Patterns\n\n### Search Across All Tag Types\n```javascript\n// Client-side filtering for mixed tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  const hasStructuredMatch = structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n  \n  // Search legacy tags\n  const hasLegacyMatch = (doc.legacyTags || doc.tags || [])\n    .some(tag => tag.toLowerCase().includes(searchTerm));\n    \n  return hasStructuredMatch || hasLegacyMatch;\n});\n```\n\n### Category-Based Filtering\n```javascript\n// Filter by specific category and tags\nconst categoryFilters = {\n  'cat-doc-type': ['Invoice', 'Statement'],\n  'cat-institution': ['Bank of America']\n};\n\nevidence.filter(doc => {\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  \n  return Object.entries(categoryFilters).every(([categoryId, selectedTags]) => {\n    return structuredTags.some(tag => \n      tag.categoryId === categoryId && \n      selectedTags.includes(tag.tagName)\n    );\n  });\n});\n```\n\n## Performance Considerations\n\n### Indexing Strategy\n```javascript\n// Composite indexes for efficient queries\n[\n  ['tagsByHuman.categoryId', 'updatedAt'],\n  ['tagsByHuman.tagName', 'updatedAt'],\n  ['tagsByAI.categoryId', 'confidence', 'updatedAt']\n]\n```\n\n### Denormalization Benefits\n- **Category names** stored in each tag for fast display\n- **Colors** stored in tags to avoid category lookups\n- **Tag counts** computed and stored for quick statistics\n\n### Memory Management\n- **Lazy loading** of tag details when needed\n- **Pagination** for documents with many tags\n- **Caching** of frequently accessed category data\n\n## Rollback Plan\n\n### Emergency Rollback to v1.0\n1. **Revert components** to use `tags` array only\n2. **Disable structured tag features** via feature flags\n3. **Preserve all data** - no data loss during rollback\n4. **Migration can resume** when issues are resolved\n\n### Rollback Implementation\n```javascript\n// Feature flag for emergency rollback\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Fallback tag display\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return evidence.legacyTags || evidence.tags || [];\n};\n```\n\n## Testing Requirements\n\n### Unit Tests\n- [ ] Structured tag validation\n- [ ] Migration utilities  \n- [ ] Search across mixed tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Legacy tag preservation during updates\n- [ ] Migration from v1.0 to v1.1 format\n- [ ] Rollback to v1.0 compatibility\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms with mixed tags\n- [ ] Memory usage with large tag datasets","structuredPatch":[{"oldStart":2,"oldLines":7,"newStart":2,"newLines":7,"lines":[" "," ## Overview"," ","-This document defines the updated Evidence document structure for Organizer v1.1, which introduces structured category-based tagging while maintaining full backward compatibility with v1.0.","+This document defines the Evidence document structure for Organizer v1.1, featuring structured category-based tagging. Since we are starting with a clean slate (all data and documents have been deleted), this version will be the initial implementation without migration considerations."," "," ## Database Location"," ```"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"674fffe9-24d8-4bbe-bdf9-a4586680741d","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01J5cHiqnJBa7cQvjcdUR6Jt","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01FB1T2Xmwzra9hPQShQRZVg","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","old_string":"## Updated Evidence Document Structure\n\n### Current v1.0 Structure (Preserved)\n```javascript\n{\n  // === FILE REFERENCES (Unchanged) ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES (Unchanged) ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS (Unchanged) ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === LEGACY TAGS (Preserved for Compatibility) ===\n  tags: string[],           // v1.0 free-form tags - PRESERVED\n  tagCount: number,         // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai' | 'migration',\n  \n  // === TIMESTAMPS (Unchanged) ===\n  updatedAt: timestamp\n}\n```\n\n### New v1.1 Structured Tags\n```javascript\n{\n  // === NEW STRUCTURED TAGS ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (v1.2 preparation)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === MIGRATION SUPPORT ===\n  legacyTags: string[],     // Explicit storage of original v1.0 tags\n  migrationStatus: 'pending' | 'completed' | 'skipped',\n  migratedAt: timestamp,    // When migration was performed\n  \n  // === UPDATED COMPUTED FIELDS ===\n  tagCount: number         // Total: tagsByHuman.length + tagsByAI.length + legacyTags.length\n}\n```\n\n## Complete v1.1 Evidence Document Schema","new_string":"## Evidence Document Structure"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":456,"cache_read_input_tokens":26970,"cache_creation":{"ephemeral_5m_input_tokens":456,"ephemeral_1h_input_tokens":0},"output_tokens":780,"service_tier":"standard"}},"requestId":"req_011CSfGzx1w91zMaSTveFTq9","type":"assistant","uuid":"cde6adff-1dbc-478b-aebd-aa91a73afe8a","timestamp":"2025-08-31T05:59:57.539Z"}
{"parentUuid":"cde6adff-1dbc-478b-aebd-aa91a73afe8a","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FB1T2Xmwzra9hPQShQRZVg","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     8→```\n     9→/teams/{teamId}/evidence/{evidenceId}\n    10→```\n    11→\n    12→## Evidence Document Structure\n    13→\n    14→```javascript\n    15→{\n    16→  // === FILE REFERENCES ==="}]},"uuid":"787f1496-15e5-43ad-bd93-70ca334fa351","timestamp":"2025-08-31T05:59:57.600Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","oldString":"## Updated Evidence Document Structure\n\n### Current v1.0 Structure (Preserved)\n```javascript\n{\n  // === FILE REFERENCES (Unchanged) ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES (Unchanged) ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS (Unchanged) ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === LEGACY TAGS (Preserved for Compatibility) ===\n  tags: string[],           // v1.0 free-form tags - PRESERVED\n  tagCount: number,         // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai' | 'migration',\n  \n  // === TIMESTAMPS (Unchanged) ===\n  updatedAt: timestamp\n}\n```\n\n### New v1.1 Structured Tags\n```javascript\n{\n  // === NEW STRUCTURED TAGS ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (v1.2 preparation)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === MIGRATION SUPPORT ===\n  legacyTags: string[],     // Explicit storage of original v1.0 tags\n  migrationStatus: 'pending' | 'completed' | 'skipped',\n  migratedAt: timestamp,    // When migration was performed\n  \n  // === UPDATED COMPUTED FIELDS ===\n  tagCount: number         // Total: tagsByHuman.length + tagsByAI.length + legacyTags.length\n}\n```\n\n## Complete v1.1 Evidence Document Schema","newString":"## Evidence Document Structure","originalFile":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the Evidence document structure for Organizer v1.1, featuring structured category-based tagging. Since we are starting with a clean slate (all data and documents have been deleted), this version will be the initial implementation without migration considerations.\n\n## Database Location\n```\n/teams/{teamId}/evidence/{evidenceId}\n```\n\n## Updated Evidence Document Structure\n\n### Current v1.0 Structure (Preserved)\n```javascript\n{\n  // === FILE REFERENCES (Unchanged) ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES (Unchanged) ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS (Unchanged) ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === LEGACY TAGS (Preserved for Compatibility) ===\n  tags: string[],           // v1.0 free-form tags - PRESERVED\n  tagCount: number,         // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai' | 'migration',\n  \n  // === TIMESTAMPS (Unchanged) ===\n  updatedAt: timestamp\n}\n```\n\n### New v1.1 Structured Tags\n```javascript\n{\n  // === NEW STRUCTURED TAGS ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (v1.2 preparation)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === MIGRATION SUPPORT ===\n  legacyTags: string[],     // Explicit storage of original v1.0 tags\n  migrationStatus: 'pending' | 'completed' | 'skipped',\n  migratedAt: timestamp,    // When migration was performed\n  \n  // === UPDATED COMPUTED FIELDS ===\n  tagCount: number         // Total: tagsByHuman.length + tagsByAI.length + legacyTags.length\n}\n```\n\n## Complete v1.1 Evidence Document Schema\n\n```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string\n  },\n  \n  displayCopy: {\n    metadataHash: string,\n    folderPath: string\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM (v1.1) ===\n  tagsByHuman: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string\n    }\n  ],\n  \n  tagsByAI: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number\n    }\n  ],\n  \n  // === BACKWARD COMPATIBILITY ===\n  tags: string[],              // v1.0 tags - preserved for compatibility\n  legacyTags: string[],        // Explicit legacy tag storage\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai' | 'migration',\n  migrationStatus: 'pending' | 'completed' | 'skipped',\n  migratedAt: timestamp,\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```\n\n## Migration Strategy\n\n### Phase 1: Non-Breaking Schema Extension\n1. **Add new fields** without removing existing fields\n2. **Preserve `tags` array** for v1.0 compatibility  \n3. **Add `legacyTags` array** for explicit legacy storage\n4. **Initialize structured arrays** as empty (`tagsByHuman: [], tagsByAI: []`)\n\n### Phase 2: Data Population  \n1. **Copy `tags` to `legacyTags`** for all existing documents\n2. **User-initiated migration** converts legacy tags to structured format\n3. **Preserve original `tags` array** until user confirms migration\n\n### Phase 3: Gradual Transition\n1. **New tags** created using structured format\n2. **Search** includes both structured and legacy tags\n3. **Display** prioritizes structured tags, falls back to legacy\n\n## Validation Rules\n\n### Structured Tag Validation\n```javascript\n// tagsByHuman and tagsByAI validation\n{\n  categoryId: {\n    required: true,\n    type: 'string',\n    pattern: /^[a-zA-Z0-9_-]+$/ // Valid Firestore document ID\n  },\n  categoryName: {\n    required: true,\n    type: 'string',\n    maxLength: 50\n  },\n  tagId: {\n    required: true,\n    type: 'string',\n    format: 'uuid' // Generated using crypto.randomUUID()\n  },\n  tagName: {\n    required: true,\n    type: 'string',\n    maxLength: 30\n  },\n  color: {\n    required: true,\n    type: 'string',\n    pattern: /^#[0-9A-Fa-f]{6}$/ // Valid hex color\n  },\n  confidence: { // AI tags only\n    type: 'number',\n    minimum: 0.0,\n    maximum: 1.0\n  }\n}\n```\n\n### Document-Level Constraints\n- **Maximum 100 structured tags per document** (tagsByHuman + tagsByAI)\n- **Maximum 50 tags per category** per document\n- **Category must exist** and be active when adding structured tags\n- **Tag names within category must be unique** per document\n\n## Firestore Security Rules\n\n### Updated Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', [])) &&\n    preserveLegacyTags(resource.data, request.resource.data);\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n\nfunction preserveLegacyTags(oldData, newData) {\n  // Ensure legacyTags are not deleted during updates\n  return newData.get('legacyTags', []).hasAll(oldData.get('legacyTags', []));\n}\n```\n\n## Query Patterns\n\n### Search Across All Tag Types\n```javascript\n// Client-side filtering for mixed tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  const hasStructuredMatch = structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n  \n  // Search legacy tags\n  const hasLegacyMatch = (doc.legacyTags || doc.tags || [])\n    .some(tag => tag.toLowerCase().includes(searchTerm));\n    \n  return hasStructuredMatch || hasLegacyMatch;\n});\n```\n\n### Category-Based Filtering\n```javascript\n// Filter by specific category and tags\nconst categoryFilters = {\n  'cat-doc-type': ['Invoice', 'Statement'],\n  'cat-institution': ['Bank of America']\n};\n\nevidence.filter(doc => {\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  \n  return Object.entries(categoryFilters).every(([categoryId, selectedTags]) => {\n    return structuredTags.some(tag => \n      tag.categoryId === categoryId && \n      selectedTags.includes(tag.tagName)\n    );\n  });\n});\n```\n\n## Performance Considerations\n\n### Indexing Strategy\n```javascript\n// Composite indexes for efficient queries\n[\n  ['tagsByHuman.categoryId', 'updatedAt'],\n  ['tagsByHuman.tagName', 'updatedAt'],\n  ['tagsByAI.categoryId', 'confidence', 'updatedAt']\n]\n```\n\n### Denormalization Benefits\n- **Category names** stored in each tag for fast display\n- **Colors** stored in tags to avoid category lookups\n- **Tag counts** computed and stored for quick statistics\n\n### Memory Management\n- **Lazy loading** of tag details when needed\n- **Pagination** for documents with many tags\n- **Caching** of frequently accessed category data\n\n## Rollback Plan\n\n### Emergency Rollback to v1.0\n1. **Revert components** to use `tags` array only\n2. **Disable structured tag features** via feature flags\n3. **Preserve all data** - no data loss during rollback\n4. **Migration can resume** when issues are resolved\n\n### Rollback Implementation\n```javascript\n// Feature flag for emergency rollback\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Fallback tag display\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return evidence.legacyTags || evidence.tags || [];\n};\n```\n\n## Testing Requirements\n\n### Unit Tests\n- [ ] Structured tag validation\n- [ ] Migration utilities  \n- [ ] Search across mixed tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Legacy tag preservation during updates\n- [ ] Migration from v1.0 to v1.1 format\n- [ ] Rollback to v1.0 compatibility\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms with mixed tags\n- [ ] Memory usage with large tag datasets","structuredPatch":[{"oldStart":9,"oldLines":80,"newStart":9,"newLines":10,"lines":[" /teams/{teamId}/evidence/{evidenceId}"," ```"," ","-## Updated Evidence Document Structure","+## Evidence Document Structure"," ","-### Current v1.0 Structure (Preserved)"," ```javascript"," {","-  // === FILE REFERENCES (Unchanged) ===","-  storageRef: {","-    storage: 'uploads',","-    fileHash: string  // SHA-256 hash of file content","-  },","-  ","-  displayCopy: {","-    metadataHash: string,  // Reference to originalMetadata document","-    folderPath: string     // Original folder path from upload","-  },","-  ","-  // === FILE PROPERTIES (Unchanged) ===","-  fileSize: number,","-  ","-  // === PROCESSING STATUS (Unchanged) ===","-  isProcessed: boolean,","-  hasAllPages: boolean | null,","-  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',","-  ","-  // === LEGACY TAGS (Preserved for Compatibility) ===","-  tags: string[],           // v1.0 free-form tags - PRESERVED","-  tagCount: number,         // Total count of all tags","-  lastTaggedAt: timestamp,","-  taggedBy: 'manual' | 'ai' | 'migration',","-  ","-  // === TIMESTAMPS (Unchanged) ===","-  updatedAt: timestamp","-}","-```","-","-### New v1.1 Structured Tags","-```javascript","-{","-  // === NEW STRUCTURED TAGS ===","-  tagsByHuman: [            // Human-assigned structured tags","-    {","-      categoryId: string,      // Reference to category document ID","-      categoryName: string,    // Denormalized category name for performance","-      tagId: string,          // Unique identifier for this tag instance","-      tagName: string,        // Display name of the tag","-      color: string          // Hex color code (e.g., '#1976d2')","-    }","-  ],","-  ","-  tagsByAI: [               // AI-assigned structured tags (v1.2 preparation)","-    {","-      categoryId: string,","-      categoryName: string,","-      tagId: string,","-      tagName: string,","-      color: string,","-      confidence: number     // AI confidence score (0.0 - 1.0)","-    }","-  ],","-  ","-  // === MIGRATION SUPPORT ===","-  legacyTags: string[],     // Explicit storage of original v1.0 tags","-  migrationStatus: 'pending' | 'completed' | 'skipped',","-  migratedAt: timestamp,    // When migration was performed","-  ","-  // === UPDATED COMPUTED FIELDS ===","-  tagCount: number         // Total: tagsByHuman.length + tagsByAI.length + legacyTags.length","-}","-```","-","-## Complete v1.1 Evidence Document Schema","-","-```javascript","-{","   // === FILE REFERENCES ===","   storageRef: {","     storage: 'uploads',"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"787f1496-15e5-43ad-bd93-70ca334fa351","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01NVo8sq9ScVk4aQqeTrZB6D","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01FowLAeykg7A2XqrA9iPk2P","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","old_string":"```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string\n  },\n  \n  displayCopy: {\n    metadataHash: string,\n    folderPath: string\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM (v1.1) ===\n  tagsByHuman: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string\n    }\n  ],\n  \n  tagsByAI: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number\n    }\n  ],\n  \n  // === BACKWARD COMPATIBILITY ===\n  tags: string[],              // v1.0 tags - preserved for compatibility\n  legacyTags: string[],        // Explicit legacy tag storage\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai' | 'migration',\n  migrationStatus: 'pending' | 'completed' | 'skipped',\n  migratedAt: timestamp,\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```","new_string":"```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (future v1.2)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai',\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":912,"cache_read_input_tokens":27426,"cache_creation":{"ephemeral_5m_input_tokens":912,"ephemeral_1h_input_tokens":0},"output_tokens":57,"service_tier":"standard"}},"requestId":"req_011CSfH1puKocFurMA7Mya5R","type":"assistant","uuid":"1588ed3c-eb55-47f4-bf8b-f035f900478b","timestamp":"2025-08-31T06:00:11.289Z"}
{"parentUuid":"1588ed3c-eb55-47f4-bf8b-f035f900478b","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FowLAeykg7A2XqrA9iPk2P","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    10→```\n    11→\n    12→## Evidence Document Structure\n    13→\n    14→```javascript\n    15→{\n    16→  // === FILE REFERENCES ===\n    17→  storageRef: {\n    18→    storage: 'uploads',\n    19→    fileHash: string  // SHA-256 hash of file content\n    20→  },\n    21→  \n    22→  displayCopy: {\n    23→    metadataHash: string,  // Reference to originalMetadata document\n    24→    folderPath: string     // Original folder path from upload\n    25→  },\n    26→  \n    27→  // === FILE PROPERTIES ===\n    28→  fileSize: number,\n    29→  \n    30→  // === PROCESSING STATUS ===\n    31→  isProcessed: boolean,\n    32→  hasAllPages: boolean | null,\n    33→  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n    34→  \n    35→  // === STRUCTURED TAGGING SYSTEM ===\n    36→  tagsByHuman: [            // Human-assigned structured tags\n    37→    {\n    38→      categoryId: string,      // Reference to category document ID\n    39→      categoryName: string,    // Denormalized category name for performance\n    40→      tagId: string,          // Unique identifier for this tag instance\n    41→      tagName: string,        // Display name of the tag\n    42→      color: string          // Hex color code (e.g., '#1976d2')\n    43→    }\n    44→  ],\n    45→  \n    46→  tagsByAI: [               // AI-assigned structured tags (future v1.2)\n    47→    {\n    48→      categoryId: string,\n    49→      categoryName: string,\n    50→      tagId: string,\n    51→      tagName: string,\n    52→      color: string,\n    53→      confidence: number     // AI confidence score (0.0 - 1.0)\n    54→    }\n    55→  ],\n    56→  \n    57→  // === METADATA ===\n    58→  tagCount: number,            // Total count of all tags\n    59→  lastTaggedAt: timestamp,\n    60→  taggedBy: 'manual' | 'ai',\n    61→  \n    62→  // === TIMESTAMPS ===\n    63→  updatedAt: timestamp\n    64→}\n    65→```\n    66→\n    67→## Migration Strategy\n    68→\n    69→### Phase 1: Non-Breaking Schema Extension"}]},"uuid":"ad0a4be9-ad81-4a56-a888-e35db34c5d05","timestamp":"2025-08-31T06:00:11.375Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","oldString":"```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string\n  },\n  \n  displayCopy: {\n    metadataHash: string,\n    folderPath: string\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM (v1.1) ===\n  tagsByHuman: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string\n    }\n  ],\n  \n  tagsByAI: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number\n    }\n  ],\n  \n  // === BACKWARD COMPATIBILITY ===\n  tags: string[],              // v1.0 tags - preserved for compatibility\n  legacyTags: string[],        // Explicit legacy tag storage\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai' | 'migration',\n  migrationStatus: 'pending' | 'completed' | 'skipped',\n  migratedAt: timestamp,\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```","newString":"```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (future v1.2)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai',\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```","originalFile":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the Evidence document structure for Organizer v1.1, featuring structured category-based tagging. Since we are starting with a clean slate (all data and documents have been deleted), this version will be the initial implementation without migration considerations.\n\n## Database Location\n```\n/teams/{teamId}/evidence/{evidenceId}\n```\n\n## Evidence Document Structure\n\n```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string\n  },\n  \n  displayCopy: {\n    metadataHash: string,\n    folderPath: string\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM (v1.1) ===\n  tagsByHuman: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string\n    }\n  ],\n  \n  tagsByAI: [\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number\n    }\n  ],\n  \n  // === BACKWARD COMPATIBILITY ===\n  tags: string[],              // v1.0 tags - preserved for compatibility\n  legacyTags: string[],        // Explicit legacy tag storage\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai' | 'migration',\n  migrationStatus: 'pending' | 'completed' | 'skipped',\n  migratedAt: timestamp,\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```\n\n## Migration Strategy\n\n### Phase 1: Non-Breaking Schema Extension\n1. **Add new fields** without removing existing fields\n2. **Preserve `tags` array** for v1.0 compatibility  \n3. **Add `legacyTags` array** for explicit legacy storage\n4. **Initialize structured arrays** as empty (`tagsByHuman: [], tagsByAI: []`)\n\n### Phase 2: Data Population  \n1. **Copy `tags` to `legacyTags`** for all existing documents\n2. **User-initiated migration** converts legacy tags to structured format\n3. **Preserve original `tags` array** until user confirms migration\n\n### Phase 3: Gradual Transition\n1. **New tags** created using structured format\n2. **Search** includes both structured and legacy tags\n3. **Display** prioritizes structured tags, falls back to legacy\n\n## Validation Rules\n\n### Structured Tag Validation\n```javascript\n// tagsByHuman and tagsByAI validation\n{\n  categoryId: {\n    required: true,\n    type: 'string',\n    pattern: /^[a-zA-Z0-9_-]+$/ // Valid Firestore document ID\n  },\n  categoryName: {\n    required: true,\n    type: 'string',\n    maxLength: 50\n  },\n  tagId: {\n    required: true,\n    type: 'string',\n    format: 'uuid' // Generated using crypto.randomUUID()\n  },\n  tagName: {\n    required: true,\n    type: 'string',\n    maxLength: 30\n  },\n  color: {\n    required: true,\n    type: 'string',\n    pattern: /^#[0-9A-Fa-f]{6}$/ // Valid hex color\n  },\n  confidence: { // AI tags only\n    type: 'number',\n    minimum: 0.0,\n    maximum: 1.0\n  }\n}\n```\n\n### Document-Level Constraints\n- **Maximum 100 structured tags per document** (tagsByHuman + tagsByAI)\n- **Maximum 50 tags per category** per document\n- **Category must exist** and be active when adding structured tags\n- **Tag names within category must be unique** per document\n\n## Firestore Security Rules\n\n### Updated Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', [])) &&\n    preserveLegacyTags(resource.data, request.resource.data);\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n\nfunction preserveLegacyTags(oldData, newData) {\n  // Ensure legacyTags are not deleted during updates\n  return newData.get('legacyTags', []).hasAll(oldData.get('legacyTags', []));\n}\n```\n\n## Query Patterns\n\n### Search Across All Tag Types\n```javascript\n// Client-side filtering for mixed tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  const hasStructuredMatch = structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n  \n  // Search legacy tags\n  const hasLegacyMatch = (doc.legacyTags || doc.tags || [])\n    .some(tag => tag.toLowerCase().includes(searchTerm));\n    \n  return hasStructuredMatch || hasLegacyMatch;\n});\n```\n\n### Category-Based Filtering\n```javascript\n// Filter by specific category and tags\nconst categoryFilters = {\n  'cat-doc-type': ['Invoice', 'Statement'],\n  'cat-institution': ['Bank of America']\n};\n\nevidence.filter(doc => {\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  \n  return Object.entries(categoryFilters).every(([categoryId, selectedTags]) => {\n    return structuredTags.some(tag => \n      tag.categoryId === categoryId && \n      selectedTags.includes(tag.tagName)\n    );\n  });\n});\n```\n\n## Performance Considerations\n\n### Indexing Strategy\n```javascript\n// Composite indexes for efficient queries\n[\n  ['tagsByHuman.categoryId', 'updatedAt'],\n  ['tagsByHuman.tagName', 'updatedAt'],\n  ['tagsByAI.categoryId', 'confidence', 'updatedAt']\n]\n```\n\n### Denormalization Benefits\n- **Category names** stored in each tag for fast display\n- **Colors** stored in tags to avoid category lookups\n- **Tag counts** computed and stored for quick statistics\n\n### Memory Management\n- **Lazy loading** of tag details when needed\n- **Pagination** for documents with many tags\n- **Caching** of frequently accessed category data\n\n## Rollback Plan\n\n### Emergency Rollback to v1.0\n1. **Revert components** to use `tags` array only\n2. **Disable structured tag features** via feature flags\n3. **Preserve all data** - no data loss during rollback\n4. **Migration can resume** when issues are resolved\n\n### Rollback Implementation\n```javascript\n// Feature flag for emergency rollback\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Fallback tag display\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return evidence.legacyTags || evidence.tags || [];\n};\n```\n\n## Testing Requirements\n\n### Unit Tests\n- [ ] Structured tag validation\n- [ ] Migration utilities  \n- [ ] Search across mixed tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Legacy tag preservation during updates\n- [ ] Migration from v1.0 to v1.1 format\n- [ ] Rollback to v1.0 compatibility\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms with mixed tags\n- [ ] Memory usage with large tag datasets","structuredPatch":[{"oldStart":16,"oldLines":12,"newStart":16,"newLines":12,"lines":["   // === FILE REFERENCES ===","   storageRef: {","     storage: 'uploads',","-    fileHash: string","+    fileHash: string  // SHA-256 hash of file content","   },","   ","   displayCopy: {","-    metadataHash: string,","-    folderPath: string","+    metadataHash: string,  // Reference to originalMetadata document","+    folderPath: string     // Original folder path from upload","   },","   ","   // === FILE PROPERTIES ==="]},{"oldStart":32,"oldLines":38,"newStart":32,"newLines":32,"lines":["   hasAllPages: boolean | null,","   processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',","   ","-  // === STRUCTURED TAGGING SYSTEM (v1.1) ===","-  tagsByHuman: [","+  // === STRUCTURED TAGGING SYSTEM ===","+  tagsByHuman: [            // Human-assigned structured tags","     {","-      categoryId: string,","-      categoryName: string,","-      tagId: string,","-      tagName: string,","-      color: string","+      categoryId: string,      // Reference to category document ID","+      categoryName: string,    // Denormalized category name for performance","+      tagId: string,          // Unique identifier for this tag instance","+      tagName: string,        // Display name of the tag","+      color: string          // Hex color code (e.g., '#1976d2')","     }","   ],","   ","-  tagsByAI: [","+  tagsByAI: [               // AI-assigned structured tags (future v1.2)","     {","       categoryId: string,","       categoryName: string,","       tagId: string,","       tagName: string,","       color: string,","-      confidence: number","+      confidence: number     // AI confidence score (0.0 - 1.0)","     }","   ],","   ","-  // === BACKWARD COMPATIBILITY ===","-  tags: string[],              // v1.0 tags - preserved for compatibility","-  legacyTags: string[],        // Explicit legacy tag storage","-  ","   // === METADATA ===","   tagCount: number,            // Total count of all tags","   lastTaggedAt: timestamp,","-  taggedBy: 'manual' | 'ai' | 'migration',","-  migrationStatus: 'pending' | 'completed' | 'skipped',","-  migratedAt: timestamp,","+  taggedBy: 'manual' | 'ai',","   ","   // === TIMESTAMPS ===","   updatedAt: timestamp"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"ad0a4be9-ad81-4a56-a888-e35db34c5d05","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01Vpg1FBXdVo55HQCQxpbFZE","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01S8qSsas78EUXvxDMJzHKiA","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","old_string":"## Migration Strategy\n\n### Phase 1: Non-Breaking Schema Extension\n1. **Add new fields** without removing existing fields\n2. **Preserve `tags` array** for v1.0 compatibility  \n3. **Add `legacyTags` array** for explicit legacy storage\n4. **Initialize structured arrays** as empty (`tagsByHuman: [], tagsByAI: []`)\n\n### Phase 2: Data Population  \n1. **Copy `tags` to `legacyTags`** for all existing documents\n2. **User-initiated migration** converts legacy tags to structured format\n3. **Preserve original `tags` array** until user confirms migration\n\n### Phase 3: Gradual Transition\n1. **New tags** created using structured format\n2. **Search** includes both structured and legacy tags\n3. **Display** prioritizes structured tags, falls back to legacy","new_string":"## Implementation Notes\n\nSince we are starting with a clean database:\n1. **All new evidence documents** will use the structured tagging format from the start\n2. **No migration required** - this is the initial implementation\n3. **tagsByHuman and tagsByAI** arrays will be initialized as empty arrays\n4. **Clean, consistent data structure** across all documents"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":1699,"cache_read_input_tokens":28338,"cache_creation":{"ephemeral_5m_input_tokens":1699,"ephemeral_1h_input_tokens":0},"output_tokens":395,"service_tier":"standard"}},"requestId":"req_011CSfH2qjDN5Towaw5FjDVr","type":"assistant","uuid":"9360d7b3-9f22-47b7-8cb6-103046bed6e0","timestamp":"2025-08-31T06:00:20.787Z"}
{"parentUuid":"9360d7b3-9f22-47b7-8cb6-103046bed6e0","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S8qSsas78EUXvxDMJzHKiA","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    63→  updatedAt: timestamp\n    64→}\n    65→```\n    66→\n    67→## Implementation Notes\n    68→\n    69→Since we are starting with a clean database:\n    70→1. **All new evidence documents** will use the structured tagging format from the start\n    71→2. **No migration required** - this is the initial implementation\n    72→3. **tagsByHuman and tagsByAI** arrays will be initialized as empty arrays\n    73→4. **Clean, consistent data structure** across all documents\n    74→\n    75→## Validation Rules\n    76→\n    77→### Structured Tag Validation"}]},"uuid":"f58a4c4f-0ac4-4852-9a27-d04a3aa269d6","timestamp":"2025-08-31T06:00:20.840Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","oldString":"## Migration Strategy\n\n### Phase 1: Non-Breaking Schema Extension\n1. **Add new fields** without removing existing fields\n2. **Preserve `tags` array** for v1.0 compatibility  \n3. **Add `legacyTags` array** for explicit legacy storage\n4. **Initialize structured arrays** as empty (`tagsByHuman: [], tagsByAI: []`)\n\n### Phase 2: Data Population  \n1. **Copy `tags` to `legacyTags`** for all existing documents\n2. **User-initiated migration** converts legacy tags to structured format\n3. **Preserve original `tags` array** until user confirms migration\n\n### Phase 3: Gradual Transition\n1. **New tags** created using structured format\n2. **Search** includes both structured and legacy tags\n3. **Display** prioritizes structured tags, falls back to legacy","newString":"## Implementation Notes\n\nSince we are starting with a clean database:\n1. **All new evidence documents** will use the structured tagging format from the start\n2. **No migration required** - this is the initial implementation\n3. **tagsByHuman and tagsByAI** arrays will be initialized as empty arrays\n4. **Clean, consistent data structure** across all documents","originalFile":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the Evidence document structure for Organizer v1.1, featuring structured category-based tagging. Since we are starting with a clean slate (all data and documents have been deleted), this version will be the initial implementation without migration considerations.\n\n## Database Location\n```\n/teams/{teamId}/evidence/{evidenceId}\n```\n\n## Evidence Document Structure\n\n```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (future v1.2)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai',\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```\n\n## Migration Strategy\n\n### Phase 1: Non-Breaking Schema Extension\n1. **Add new fields** without removing existing fields\n2. **Preserve `tags` array** for v1.0 compatibility  \n3. **Add `legacyTags` array** for explicit legacy storage\n4. **Initialize structured arrays** as empty (`tagsByHuman: [], tagsByAI: []`)\n\n### Phase 2: Data Population  \n1. **Copy `tags` to `legacyTags`** for all existing documents\n2. **User-initiated migration** converts legacy tags to structured format\n3. **Preserve original `tags` array** until user confirms migration\n\n### Phase 3: Gradual Transition\n1. **New tags** created using structured format\n2. **Search** includes both structured and legacy tags\n3. **Display** prioritizes structured tags, falls back to legacy\n\n## Validation Rules\n\n### Structured Tag Validation\n```javascript\n// tagsByHuman and tagsByAI validation\n{\n  categoryId: {\n    required: true,\n    type: 'string',\n    pattern: /^[a-zA-Z0-9_-]+$/ // Valid Firestore document ID\n  },\n  categoryName: {\n    required: true,\n    type: 'string',\n    maxLength: 50\n  },\n  tagId: {\n    required: true,\n    type: 'string',\n    format: 'uuid' // Generated using crypto.randomUUID()\n  },\n  tagName: {\n    required: true,\n    type: 'string',\n    maxLength: 30\n  },\n  color: {\n    required: true,\n    type: 'string',\n    pattern: /^#[0-9A-Fa-f]{6}$/ // Valid hex color\n  },\n  confidence: { // AI tags only\n    type: 'number',\n    minimum: 0.0,\n    maximum: 1.0\n  }\n}\n```\n\n### Document-Level Constraints\n- **Maximum 100 structured tags per document** (tagsByHuman + tagsByAI)\n- **Maximum 50 tags per category** per document\n- **Category must exist** and be active when adding structured tags\n- **Tag names within category must be unique** per document\n\n## Firestore Security Rules\n\n### Updated Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', [])) &&\n    preserveLegacyTags(resource.data, request.resource.data);\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n\nfunction preserveLegacyTags(oldData, newData) {\n  // Ensure legacyTags are not deleted during updates\n  return newData.get('legacyTags', []).hasAll(oldData.get('legacyTags', []));\n}\n```\n\n## Query Patterns\n\n### Search Across All Tag Types\n```javascript\n// Client-side filtering for mixed tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  const hasStructuredMatch = structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n  \n  // Search legacy tags\n  const hasLegacyMatch = (doc.legacyTags || doc.tags || [])\n    .some(tag => tag.toLowerCase().includes(searchTerm));\n    \n  return hasStructuredMatch || hasLegacyMatch;\n});\n```\n\n### Category-Based Filtering\n```javascript\n// Filter by specific category and tags\nconst categoryFilters = {\n  'cat-doc-type': ['Invoice', 'Statement'],\n  'cat-institution': ['Bank of America']\n};\n\nevidence.filter(doc => {\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  \n  return Object.entries(categoryFilters).every(([categoryId, selectedTags]) => {\n    return structuredTags.some(tag => \n      tag.categoryId === categoryId && \n      selectedTags.includes(tag.tagName)\n    );\n  });\n});\n```\n\n## Performance Considerations\n\n### Indexing Strategy\n```javascript\n// Composite indexes for efficient queries\n[\n  ['tagsByHuman.categoryId', 'updatedAt'],\n  ['tagsByHuman.tagName', 'updatedAt'],\n  ['tagsByAI.categoryId', 'confidence', 'updatedAt']\n]\n```\n\n### Denormalization Benefits\n- **Category names** stored in each tag for fast display\n- **Colors** stored in tags to avoid category lookups\n- **Tag counts** computed and stored for quick statistics\n\n### Memory Management\n- **Lazy loading** of tag details when needed\n- **Pagination** for documents with many tags\n- **Caching** of frequently accessed category data\n\n## Rollback Plan\n\n### Emergency Rollback to v1.0\n1. **Revert components** to use `tags` array only\n2. **Disable structured tag features** via feature flags\n3. **Preserve all data** - no data loss during rollback\n4. **Migration can resume** when issues are resolved\n\n### Rollback Implementation\n```javascript\n// Feature flag for emergency rollback\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Fallback tag display\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return evidence.legacyTags || evidence.tags || [];\n};\n```\n\n## Testing Requirements\n\n### Unit Tests\n- [ ] Structured tag validation\n- [ ] Migration utilities  \n- [ ] Search across mixed tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Legacy tag preservation during updates\n- [ ] Migration from v1.0 to v1.1 format\n- [ ] Rollback to v1.0 compatibility\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms with mixed tags\n- [ ] Memory usage with large tag datasets","structuredPatch":[{"oldStart":64,"oldLines":24,"newStart":64,"newLines":14,"lines":[" }"," ```"," ","-## Migration Strategy","+## Implementation Notes"," ","-### Phase 1: Non-Breaking Schema Extension","-1. **Add new fields** without removing existing fields","-2. **Preserve `tags` array** for v1.0 compatibility  ","-3. **Add `legacyTags` array** for explicit legacy storage","-4. **Initialize structured arrays** as empty (`tagsByHuman: [], tagsByAI: []`)","+Since we are starting with a clean database:","+1. **All new evidence documents** will use the structured tagging format from the start","+2. **No migration required** - this is the initial implementation","+3. **tagsByHuman and tagsByAI** arrays will be initialized as empty arrays","+4. **Clean, consistent data structure** across all documents"," ","-### Phase 2: Data Population  ","-1. **Copy `tags` to `legacyTags`** for all existing documents","-2. **User-initiated migration** converts legacy tags to structured format","-3. **Preserve original `tags` array** until user confirms migration","-","-### Phase 3: Gradual Transition","-1. **New tags** created using structured format","-2. **Search** includes both structured and legacy tags","-3. **Display** prioritizes structured tags, falls back to legacy","-"," ## Validation Rules"," "," ### Structured Tag Validation"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"f58a4c4f-0ac4-4852-9a27-d04a3aa269d6","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01AgqCd6PXbnfSpoiJ2XWiB9","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01C83nRrFxf31XhwgnuiVw81","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","old_string":"### Updated Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', [])) &&\n    preserveLegacyTags(resource.data, request.resource.data);\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n\nfunction preserveLegacyTags(oldData, newData) {\n  // Ensure legacyTags are not deleted during updates\n  return newData.get('legacyTags', []).hasAll(oldData.get('legacyTags', []));\n}\n```","new_string":"### Security Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', []));\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n```"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":615,"cache_read_input_tokens":30037,"cache_creation":{"ephemeral_5m_input_tokens":615,"ephemeral_1h_input_tokens":0},"output_tokens":49,"service_tier":"standard"}},"requestId":"req_011CSfH3YF2JPyZZAsMa6GcR","type":"assistant","uuid":"dd5cca11-9365-49e0-b363-c4371367f151","timestamp":"2025-08-31T06:00:33.691Z"}
{"parentUuid":"dd5cca11-9365-49e0-b363-c4371367f151","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C83nRrFxf31XhwgnuiVw81","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   118→- **Tag names within category must be unique** per document\n   119→\n   120→## Firestore Security Rules\n   121→\n   122→### Security Rules for v1.1\n   123→```javascript\n   124→// Evidence document access\n   125→match /teams/{teamId}/evidence/{evidenceId} {\n   126→  allow read, write: if \n   127→    request.auth != null &&\n   128→    resource.data.get('teamId', teamId) == teamId &&\n   129→    isTeamMember(teamId);\n   130→  \n   131→  // Validate structured tags on write\n   132→  allow update: if\n   133→    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n   134→    validateStructuredTags(request.resource.data.get('tagsByAI', []));\n   135→}\n   136→\n   137→function validateStructuredTags(tags) {\n   138→  return tags.size() <= 100 &&\n   139→    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n   140→}\n   141→```\n   142→\n   143→## Query Patterns\n   144→\n   145→### Search Across All Tag Types"}]},"uuid":"9b7f2a31-5e37-45cd-9559-604df964c12d","timestamp":"2025-08-31T06:00:33.759Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","oldString":"### Updated Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', [])) &&\n    preserveLegacyTags(resource.data, request.resource.data);\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n\nfunction preserveLegacyTags(oldData, newData) {\n  // Ensure legacyTags are not deleted during updates\n  return newData.get('legacyTags', []).hasAll(oldData.get('legacyTags', []));\n}\n```","newString":"### Security Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', []));\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n```","originalFile":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the Evidence document structure for Organizer v1.1, featuring structured category-based tagging. Since we are starting with a clean slate (all data and documents have been deleted), this version will be the initial implementation without migration considerations.\n\n## Database Location\n```\n/teams/{teamId}/evidence/{evidenceId}\n```\n\n## Evidence Document Structure\n\n```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (future v1.2)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai',\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```\n\n## Implementation Notes\n\nSince we are starting with a clean database:\n1. **All new evidence documents** will use the structured tagging format from the start\n2. **No migration required** - this is the initial implementation\n3. **tagsByHuman and tagsByAI** arrays will be initialized as empty arrays\n4. **Clean, consistent data structure** across all documents\n\n## Validation Rules\n\n### Structured Tag Validation\n```javascript\n// tagsByHuman and tagsByAI validation\n{\n  categoryId: {\n    required: true,\n    type: 'string',\n    pattern: /^[a-zA-Z0-9_-]+$/ // Valid Firestore document ID\n  },\n  categoryName: {\n    required: true,\n    type: 'string',\n    maxLength: 50\n  },\n  tagId: {\n    required: true,\n    type: 'string',\n    format: 'uuid' // Generated using crypto.randomUUID()\n  },\n  tagName: {\n    required: true,\n    type: 'string',\n    maxLength: 30\n  },\n  color: {\n    required: true,\n    type: 'string',\n    pattern: /^#[0-9A-Fa-f]{6}$/ // Valid hex color\n  },\n  confidence: { // AI tags only\n    type: 'number',\n    minimum: 0.0,\n    maximum: 1.0\n  }\n}\n```\n\n### Document-Level Constraints\n- **Maximum 100 structured tags per document** (tagsByHuman + tagsByAI)\n- **Maximum 50 tags per category** per document\n- **Category must exist** and be active when adding structured tags\n- **Tag names within category must be unique** per document\n\n## Firestore Security Rules\n\n### Updated Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', [])) &&\n    preserveLegacyTags(resource.data, request.resource.data);\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n\nfunction preserveLegacyTags(oldData, newData) {\n  // Ensure legacyTags are not deleted during updates\n  return newData.get('legacyTags', []).hasAll(oldData.get('legacyTags', []));\n}\n```\n\n## Query Patterns\n\n### Search Across All Tag Types\n```javascript\n// Client-side filtering for mixed tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  const hasStructuredMatch = structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n  \n  // Search legacy tags\n  const hasLegacyMatch = (doc.legacyTags || doc.tags || [])\n    .some(tag => tag.toLowerCase().includes(searchTerm));\n    \n  return hasStructuredMatch || hasLegacyMatch;\n});\n```\n\n### Category-Based Filtering\n```javascript\n// Filter by specific category and tags\nconst categoryFilters = {\n  'cat-doc-type': ['Invoice', 'Statement'],\n  'cat-institution': ['Bank of America']\n};\n\nevidence.filter(doc => {\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  \n  return Object.entries(categoryFilters).every(([categoryId, selectedTags]) => {\n    return structuredTags.some(tag => \n      tag.categoryId === categoryId && \n      selectedTags.includes(tag.tagName)\n    );\n  });\n});\n```\n\n## Performance Considerations\n\n### Indexing Strategy\n```javascript\n// Composite indexes for efficient queries\n[\n  ['tagsByHuman.categoryId', 'updatedAt'],\n  ['tagsByHuman.tagName', 'updatedAt'],\n  ['tagsByAI.categoryId', 'confidence', 'updatedAt']\n]\n```\n\n### Denormalization Benefits\n- **Category names** stored in each tag for fast display\n- **Colors** stored in tags to avoid category lookups\n- **Tag counts** computed and stored for quick statistics\n\n### Memory Management\n- **Lazy loading** of tag details when needed\n- **Pagination** for documents with many tags\n- **Caching** of frequently accessed category data\n\n## Rollback Plan\n\n### Emergency Rollback to v1.0\n1. **Revert components** to use `tags` array only\n2. **Disable structured tag features** via feature flags\n3. **Preserve all data** - no data loss during rollback\n4. **Migration can resume** when issues are resolved\n\n### Rollback Implementation\n```javascript\n// Feature flag for emergency rollback\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Fallback tag display\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return evidence.legacyTags || evidence.tags || [];\n};\n```\n\n## Testing Requirements\n\n### Unit Tests\n- [ ] Structured tag validation\n- [ ] Migration utilities  \n- [ ] Search across mixed tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Legacy tag preservation during updates\n- [ ] Migration from v1.0 to v1.1 format\n- [ ] Rollback to v1.0 compatibility\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms with mixed tags\n- [ ] Memory usage with large tag datasets","structuredPatch":[{"oldStart":119,"oldLines":7,"newStart":119,"newLines":7,"lines":[" "," ## Firestore Security Rules"," ","-### Updated Rules for v1.1","+### Security Rules for v1.1"," ```javascript"," // Evidence document access"," match /teams/{teamId}/evidence/{evidenceId} {"]},{"oldStart":131,"oldLines":19,"newStart":131,"newLines":13,"lines":["   // Validate structured tags on write","   allow update: if","     validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&","-    validateStructuredTags(request.resource.data.get('tagsByAI', [])) &&","-    preserveLegacyTags(resource.data, request.resource.data);","+    validateStructuredTags(request.resource.data.get('tagsByAI', []));"," }"," "," function validateStructuredTags(tags) {","   return tags.size() <= 100 &&","     tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);"," }","-","-function preserveLegacyTags(oldData, newData) {","-  // Ensure legacyTags are not deleted during updates","-  return newData.get('legacyTags', []).hasAll(oldData.get('legacyTags', []));","-}"," ```"," "," ## Query Patterns"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"9b7f2a31-5e37-45cd-9559-604df964c12d","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01YE83paCD1dqPW38E5mXjL3","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01V3uT9crc2iLWTENyZATuLY","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","old_string":"### Search Across All Tag Types\n```javascript\n// Client-side filtering for mixed tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  const hasStructuredMatch = structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n  \n  // Search legacy tags\n  const hasLegacyMatch = (doc.legacyTags || doc.tags || [])\n    .some(tag => tag.toLowerCase().includes(searchTerm));\n    \n  return hasStructuredMatch || hasLegacyMatch;\n});\n```","new_string":"### Search Across Tag Types\n```javascript\n// Client-side filtering for tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  return structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n});\n```"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1084,"cache_read_input_tokens":30652,"cache_creation":{"ephemeral_5m_input_tokens":1084,"ephemeral_1h_input_tokens":0},"output_tokens":440,"service_tier":"standard"}},"requestId":"req_011CSfH4VWqryZssHSgztxUH","type":"assistant","uuid":"a6329ff8-2695-4064-88bd-d29949e1dd9c","timestamp":"2025-08-31T06:00:43.688Z"}
{"parentUuid":"a6329ff8-2695-4064-88bd-d29949e1dd9c","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01V3uT9crc2iLWTENyZATuLY","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   141→```\n   142→\n   143→## Query Patterns\n   144→\n   145→### Search Across Tag Types\n   146→```javascript\n   147→// Client-side filtering for tag search\n   148→const searchTerm = 'invoice';\n   149→\n   150→evidence.filter(doc => {\n   151→  // Search structured tags\n   152→  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n   153→  return structuredTags.some(tag => \n   154→    tag.tagName.toLowerCase().includes(searchTerm) ||\n   155→    tag.categoryName.toLowerCase().includes(searchTerm)\n   156→  );\n   157→});\n   158→```\n   159→\n   160→### Category-Based Filtering\n   161→```javascript\n   162→// Filter by specific category and tags"}]},"uuid":"df27563f-f538-41ad-8d9d-96419aa6e222","timestamp":"2025-08-31T06:00:43.745Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","oldString":"### Search Across All Tag Types\n```javascript\n// Client-side filtering for mixed tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  const hasStructuredMatch = structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n  \n  // Search legacy tags\n  const hasLegacyMatch = (doc.legacyTags || doc.tags || [])\n    .some(tag => tag.toLowerCase().includes(searchTerm));\n    \n  return hasStructuredMatch || hasLegacyMatch;\n});\n```","newString":"### Search Across Tag Types\n```javascript\n// Client-side filtering for tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  return structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n});\n```","originalFile":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the Evidence document structure for Organizer v1.1, featuring structured category-based tagging. Since we are starting with a clean slate (all data and documents have been deleted), this version will be the initial implementation without migration considerations.\n\n## Database Location\n```\n/teams/{teamId}/evidence/{evidenceId}\n```\n\n## Evidence Document Structure\n\n```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (future v1.2)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai',\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```\n\n## Implementation Notes\n\nSince we are starting with a clean database:\n1. **All new evidence documents** will use the structured tagging format from the start\n2. **No migration required** - this is the initial implementation\n3. **tagsByHuman and tagsByAI** arrays will be initialized as empty arrays\n4. **Clean, consistent data structure** across all documents\n\n## Validation Rules\n\n### Structured Tag Validation\n```javascript\n// tagsByHuman and tagsByAI validation\n{\n  categoryId: {\n    required: true,\n    type: 'string',\n    pattern: /^[a-zA-Z0-9_-]+$/ // Valid Firestore document ID\n  },\n  categoryName: {\n    required: true,\n    type: 'string',\n    maxLength: 50\n  },\n  tagId: {\n    required: true,\n    type: 'string',\n    format: 'uuid' // Generated using crypto.randomUUID()\n  },\n  tagName: {\n    required: true,\n    type: 'string',\n    maxLength: 30\n  },\n  color: {\n    required: true,\n    type: 'string',\n    pattern: /^#[0-9A-Fa-f]{6}$/ // Valid hex color\n  },\n  confidence: { // AI tags only\n    type: 'number',\n    minimum: 0.0,\n    maximum: 1.0\n  }\n}\n```\n\n### Document-Level Constraints\n- **Maximum 100 structured tags per document** (tagsByHuman + tagsByAI)\n- **Maximum 50 tags per category** per document\n- **Category must exist** and be active when adding structured tags\n- **Tag names within category must be unique** per document\n\n## Firestore Security Rules\n\n### Security Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', []));\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n```\n\n## Query Patterns\n\n### Search Across All Tag Types\n```javascript\n// Client-side filtering for mixed tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  const hasStructuredMatch = structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n  \n  // Search legacy tags\n  const hasLegacyMatch = (doc.legacyTags || doc.tags || [])\n    .some(tag => tag.toLowerCase().includes(searchTerm));\n    \n  return hasStructuredMatch || hasLegacyMatch;\n});\n```\n\n### Category-Based Filtering\n```javascript\n// Filter by specific category and tags\nconst categoryFilters = {\n  'cat-doc-type': ['Invoice', 'Statement'],\n  'cat-institution': ['Bank of America']\n};\n\nevidence.filter(doc => {\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  \n  return Object.entries(categoryFilters).every(([categoryId, selectedTags]) => {\n    return structuredTags.some(tag => \n      tag.categoryId === categoryId && \n      selectedTags.includes(tag.tagName)\n    );\n  });\n});\n```\n\n## Performance Considerations\n\n### Indexing Strategy\n```javascript\n// Composite indexes for efficient queries\n[\n  ['tagsByHuman.categoryId', 'updatedAt'],\n  ['tagsByHuman.tagName', 'updatedAt'],\n  ['tagsByAI.categoryId', 'confidence', 'updatedAt']\n]\n```\n\n### Denormalization Benefits\n- **Category names** stored in each tag for fast display\n- **Colors** stored in tags to avoid category lookups\n- **Tag counts** computed and stored for quick statistics\n\n### Memory Management\n- **Lazy loading** of tag details when needed\n- **Pagination** for documents with many tags\n- **Caching** of frequently accessed category data\n\n## Rollback Plan\n\n### Emergency Rollback to v1.0\n1. **Revert components** to use `tags` array only\n2. **Disable structured tag features** via feature flags\n3. **Preserve all data** - no data loss during rollback\n4. **Migration can resume** when issues are resolved\n\n### Rollback Implementation\n```javascript\n// Feature flag for emergency rollback\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Fallback tag display\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return evidence.legacyTags || evidence.tags || [];\n};\n```\n\n## Testing Requirements\n\n### Unit Tests\n- [ ] Structured tag validation\n- [ ] Migration utilities  \n- [ ] Search across mixed tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Legacy tag preservation during updates\n- [ ] Migration from v1.0 to v1.1 format\n- [ ] Rollback to v1.0 compatibility\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms with mixed tags\n- [ ] Memory usage with large tag datasets","structuredPatch":[{"oldStart":142,"oldLines":24,"newStart":142,"newLines":18,"lines":[" "," ## Query Patterns"," ","-### Search Across All Tag Types","+### Search Across Tag Types"," ```javascript","-// Client-side filtering for mixed tag search","+// Client-side filtering for tag search"," const searchTerm = 'invoice';"," "," evidence.filter(doc => {","   // Search structured tags","   const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];","-  const hasStructuredMatch = structuredTags.some(tag => ","+  return structuredTags.some(tag => ","     tag.tagName.toLowerCase().includes(searchTerm) ||","     tag.categoryName.toLowerCase().includes(searchTerm)","   );","-  ","-  // Search legacy tags","-  const hasLegacyMatch = (doc.legacyTags || doc.tags || [])","-    .some(tag => tag.toLowerCase().includes(searchTerm));","-    ","-  return hasStructuredMatch || hasLegacyMatch;"," });"," ```"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"df27563f-f538-41ad-8d9d-96419aa6e222","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01E16BNiuUpaVejV5iVnsi5B","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_016rrXH8hHH1EgnNw5rwhJRN","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","old_string":"## Rollback Plan\n\n### Emergency Rollback to v1.0\n1. **Revert components** to use `tags` array only\n2. **Disable structured tag features** via feature flags\n3. **Preserve all data** - no data loss during rollback\n4. **Migration can resume** when issues are resolved\n\n### Rollback Implementation\n```javascript\n// Feature flag for emergency rollback\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Fallback tag display\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return evidence.legacyTags || evidence.tags || [];\n};\n```","new_string":"## Feature Flags\n\n### Structured Tags Feature Control\n```javascript\n// Feature flag for structured tags (default enabled for clean slate)\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Tag display helper\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return []; // Clean slate - no fallback needed\n};\n```"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":727,"cache_read_input_tokens":31736,"cache_creation":{"ephemeral_5m_input_tokens":727,"ephemeral_1h_input_tokens":0},"output_tokens":465,"service_tier":"standard"}},"requestId":"req_011CSfH5ECsdTQ5ek3frQGKe","type":"assistant","uuid":"ed1e0718-4bc1-434a-a4c4-cc01199ebf6a","timestamp":"2025-08-31T06:00:57.404Z"}
{"parentUuid":"ed1e0718-4bc1-434a-a4c4-cc01199ebf6a","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016rrXH8hHH1EgnNw5rwhJRN","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   198→- **Lazy loading** of tag details when needed\n   199→- **Pagination** for documents with many tags\n   200→- **Caching** of frequently accessed category data\n   201→\n   202→## Feature Flags\n   203→\n   204→### Structured Tags Feature Control\n   205→```javascript\n   206→// Feature flag for structured tags (default enabled for clean slate)\n   207→const USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n   208→\n   209→// Tag display helper\n   210→const getDisplayTags = (evidence) => {\n   211→  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n   212→    return evidence.tagsByHuman.map(tag => tag.tagName);\n   213→  }\n   214→  return []; // Clean slate - no fallback needed\n   215→};\n   216→```\n   217→\n   218→## Testing Requirements\n   219→\n   220→### Unit Tests"}]},"uuid":"87f73a50-c0dd-46f7-a08c-8a8c166d9df5","timestamp":"2025-08-31T06:00:57.446Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","oldString":"## Rollback Plan\n\n### Emergency Rollback to v1.0\n1. **Revert components** to use `tags` array only\n2. **Disable structured tag features** via feature flags\n3. **Preserve all data** - no data loss during rollback\n4. **Migration can resume** when issues are resolved\n\n### Rollback Implementation\n```javascript\n// Feature flag for emergency rollback\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Fallback tag display\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return evidence.legacyTags || evidence.tags || [];\n};\n```","newString":"## Feature Flags\n\n### Structured Tags Feature Control\n```javascript\n// Feature flag for structured tags (default enabled for clean slate)\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Tag display helper\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return []; // Clean slate - no fallback needed\n};\n```","originalFile":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the Evidence document structure for Organizer v1.1, featuring structured category-based tagging. Since we are starting with a clean slate (all data and documents have been deleted), this version will be the initial implementation without migration considerations.\n\n## Database Location\n```\n/teams/{teamId}/evidence/{evidenceId}\n```\n\n## Evidence Document Structure\n\n```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (future v1.2)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai',\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```\n\n## Implementation Notes\n\nSince we are starting with a clean database:\n1. **All new evidence documents** will use the structured tagging format from the start\n2. **No migration required** - this is the initial implementation\n3. **tagsByHuman and tagsByAI** arrays will be initialized as empty arrays\n4. **Clean, consistent data structure** across all documents\n\n## Validation Rules\n\n### Structured Tag Validation\n```javascript\n// tagsByHuman and tagsByAI validation\n{\n  categoryId: {\n    required: true,\n    type: 'string',\n    pattern: /^[a-zA-Z0-9_-]+$/ // Valid Firestore document ID\n  },\n  categoryName: {\n    required: true,\n    type: 'string',\n    maxLength: 50\n  },\n  tagId: {\n    required: true,\n    type: 'string',\n    format: 'uuid' // Generated using crypto.randomUUID()\n  },\n  tagName: {\n    required: true,\n    type: 'string',\n    maxLength: 30\n  },\n  color: {\n    required: true,\n    type: 'string',\n    pattern: /^#[0-9A-Fa-f]{6}$/ // Valid hex color\n  },\n  confidence: { // AI tags only\n    type: 'number',\n    minimum: 0.0,\n    maximum: 1.0\n  }\n}\n```\n\n### Document-Level Constraints\n- **Maximum 100 structured tags per document** (tagsByHuman + tagsByAI)\n- **Maximum 50 tags per category** per document\n- **Category must exist** and be active when adding structured tags\n- **Tag names within category must be unique** per document\n\n## Firestore Security Rules\n\n### Security Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', []));\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n```\n\n## Query Patterns\n\n### Search Across Tag Types\n```javascript\n// Client-side filtering for tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  return structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n});\n```\n\n### Category-Based Filtering\n```javascript\n// Filter by specific category and tags\nconst categoryFilters = {\n  'cat-doc-type': ['Invoice', 'Statement'],\n  'cat-institution': ['Bank of America']\n};\n\nevidence.filter(doc => {\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  \n  return Object.entries(categoryFilters).every(([categoryId, selectedTags]) => {\n    return structuredTags.some(tag => \n      tag.categoryId === categoryId && \n      selectedTags.includes(tag.tagName)\n    );\n  });\n});\n```\n\n## Performance Considerations\n\n### Indexing Strategy\n```javascript\n// Composite indexes for efficient queries\n[\n  ['tagsByHuman.categoryId', 'updatedAt'],\n  ['tagsByHuman.tagName', 'updatedAt'],\n  ['tagsByAI.categoryId', 'confidence', 'updatedAt']\n]\n```\n\n### Denormalization Benefits\n- **Category names** stored in each tag for fast display\n- **Colors** stored in tags to avoid category lookups\n- **Tag counts** computed and stored for quick statistics\n\n### Memory Management\n- **Lazy loading** of tag details when needed\n- **Pagination** for documents with many tags\n- **Caching** of frequently accessed category data\n\n## Rollback Plan\n\n### Emergency Rollback to v1.0\n1. **Revert components** to use `tags` array only\n2. **Disable structured tag features** via feature flags\n3. **Preserve all data** - no data loss during rollback\n4. **Migration can resume** when issues are resolved\n\n### Rollback Implementation\n```javascript\n// Feature flag for emergency rollback\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Fallback tag display\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return evidence.legacyTags || evidence.tags || [];\n};\n```\n\n## Testing Requirements\n\n### Unit Tests\n- [ ] Structured tag validation\n- [ ] Migration utilities  \n- [ ] Search across mixed tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Legacy tag preservation during updates\n- [ ] Migration from v1.0 to v1.1 format\n- [ ] Rollback to v1.0 compatibility\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms with mixed tags\n- [ ] Memory usage with large tag datasets","structuredPatch":[{"oldStart":199,"oldLines":25,"newStart":199,"newLines":19,"lines":[" - **Pagination** for documents with many tags"," - **Caching** of frequently accessed category data"," ","-## Rollback Plan","+## Feature Flags"," ","-### Emergency Rollback to v1.0","-1. **Revert components** to use `tags` array only","-2. **Disable structured tag features** via feature flags","-3. **Preserve all data** - no data loss during rollback","-4. **Migration can resume** when issues are resolved","-","-### Rollback Implementation","+### Structured Tags Feature Control"," ```javascript","-// Feature flag for emergency rollback","+// Feature flag for structured tags (default enabled for clean slate)"," const USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';"," ","-// Fallback tag display","+// Tag display helper"," const getDisplayTags = (evidence) => {","   if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {","     return evidence.tagsByHuman.map(tag => tag.tagName);","   }","-  return evidence.legacyTags || evidence.tags || [];","+  return []; // Clean slate - no fallback needed"," };"," ```"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"87f73a50-c0dd-46f7-a08c-8a8c166d9df5","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01TQoGAKzciaTDoFUHn9wagc","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_01SQsmuwzXU6tYC957y73Mmq","name":"Edit","input":{"file_path":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","old_string":"### Unit Tests\n- [ ] Structured tag validation\n- [ ] Migration utilities  \n- [ ] Search across mixed tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Legacy tag preservation during updates\n- [ ] Migration from v1.0 to v1.1 format\n- [ ] Rollback to v1.0 compatibility\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms with mixed tags\n- [ ] Memory usage with large tag datasets","new_string":"### Unit Tests\n- [ ] Structured tag validation\n- [ ] Tag creation and assignment\n- [ ] Search across structured tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Tag assignment and updates\n- [ ] Category integration with tags\n- [ ] Tag deletion and cleanup\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms\n- [ ] Memory usage with large tag datasets"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":790,"cache_read_input_tokens":32463,"cache_creation":{"ephemeral_5m_input_tokens":790,"ephemeral_1h_input_tokens":0},"output_tokens":375,"service_tier":"standard"}},"requestId":"req_011CSfH6EgB96PbQQiva9bLG","type":"assistant","uuid":"53ec4150-699e-4a7f-95ac-f9e9381d388c","timestamp":"2025-08-31T06:01:12.349Z"}
{"parentUuid":"53ec4150-699e-4a7f-95ac-f9e9381d388c","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SQsmuwzXU6tYC957y73Mmq","type":"tool_result","content":"The file C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   216→```\n   217→\n   218→## Testing Requirements\n   219→\n   220→### Unit Tests\n   221→- [ ] Structured tag validation\n   222→- [ ] Tag creation and assignment\n   223→- [ ] Search across structured tag types\n   224→- [ ] Category-based filtering\n   225→\n   226→### Integration Tests\n   227→- [ ] Evidence creation with structured tags\n   228→- [ ] Tag assignment and updates\n   229→- [ ] Category integration with tags\n   230→- [ ] Tag deletion and cleanup\n   231→\n   232→### Performance Tests\n   233→- [ ] Query performance with 1000+ documents\n   234→- [ ] Tag assignment operations <500ms\n   235→- [ ] Search response time <300ms\n   236→- [ ] Memory usage with large tag datasets"}]},"uuid":"d4a8a8b8-89c1-4f95-b233-251f25a2dd43","timestamp":"2025-08-31T06:01:12.406Z","toolUseResult":{"filePath":"C:\\Users\\Brahm\\Git\\Bookkeeper\\docs\\data-structures\\evidence-v1.1-schema.md","oldString":"### Unit Tests\n- [ ] Structured tag validation\n- [ ] Migration utilities  \n- [ ] Search across mixed tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Legacy tag preservation during updates\n- [ ] Migration from v1.0 to v1.1 format\n- [ ] Rollback to v1.0 compatibility\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms with mixed tags\n- [ ] Memory usage with large tag datasets","newString":"### Unit Tests\n- [ ] Structured tag validation\n- [ ] Tag creation and assignment\n- [ ] Search across structured tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Tag assignment and updates\n- [ ] Category integration with tags\n- [ ] Tag deletion and cleanup\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms\n- [ ] Memory usage with large tag datasets","originalFile":"# Evidence Document Structure v1.1 - Category-Based Tags\n\n## Overview\n\nThis document defines the Evidence document structure for Organizer v1.1, featuring structured category-based tagging. Since we are starting with a clean slate (all data and documents have been deleted), this version will be the initial implementation without migration considerations.\n\n## Database Location\n```\n/teams/{teamId}/evidence/{evidenceId}\n```\n\n## Evidence Document Structure\n\n```javascript\n{\n  // === FILE REFERENCES ===\n  storageRef: {\n    storage: 'uploads',\n    fileHash: string  // SHA-256 hash of file content\n  },\n  \n  displayCopy: {\n    metadataHash: string,  // Reference to originalMetadata document\n    folderPath: string     // Original folder path from upload\n  },\n  \n  // === FILE PROPERTIES ===\n  fileSize: number,\n  \n  // === PROCESSING STATUS ===\n  isProcessed: boolean,\n  hasAllPages: boolean | null,\n  processingStage: 'uploaded' | 'splitting' | 'merging' | 'complete',\n  \n  // === STRUCTURED TAGGING SYSTEM ===\n  tagsByHuman: [            // Human-assigned structured tags\n    {\n      categoryId: string,      // Reference to category document ID\n      categoryName: string,    // Denormalized category name for performance\n      tagId: string,          // Unique identifier for this tag instance\n      tagName: string,        // Display name of the tag\n      color: string          // Hex color code (e.g., '#1976d2')\n    }\n  ],\n  \n  tagsByAI: [               // AI-assigned structured tags (future v1.2)\n    {\n      categoryId: string,\n      categoryName: string,\n      tagId: string,\n      tagName: string,\n      color: string,\n      confidence: number     // AI confidence score (0.0 - 1.0)\n    }\n  ],\n  \n  // === METADATA ===\n  tagCount: number,            // Total count of all tags\n  lastTaggedAt: timestamp,\n  taggedBy: 'manual' | 'ai',\n  \n  // === TIMESTAMPS ===\n  updatedAt: timestamp\n}\n```\n\n## Implementation Notes\n\nSince we are starting with a clean database:\n1. **All new evidence documents** will use the structured tagging format from the start\n2. **No migration required** - this is the initial implementation\n3. **tagsByHuman and tagsByAI** arrays will be initialized as empty arrays\n4. **Clean, consistent data structure** across all documents\n\n## Validation Rules\n\n### Structured Tag Validation\n```javascript\n// tagsByHuman and tagsByAI validation\n{\n  categoryId: {\n    required: true,\n    type: 'string',\n    pattern: /^[a-zA-Z0-9_-]+$/ // Valid Firestore document ID\n  },\n  categoryName: {\n    required: true,\n    type: 'string',\n    maxLength: 50\n  },\n  tagId: {\n    required: true,\n    type: 'string',\n    format: 'uuid' // Generated using crypto.randomUUID()\n  },\n  tagName: {\n    required: true,\n    type: 'string',\n    maxLength: 30\n  },\n  color: {\n    required: true,\n    type: 'string',\n    pattern: /^#[0-9A-Fa-f]{6}$/ // Valid hex color\n  },\n  confidence: { // AI tags only\n    type: 'number',\n    minimum: 0.0,\n    maximum: 1.0\n  }\n}\n```\n\n### Document-Level Constraints\n- **Maximum 100 structured tags per document** (tagsByHuman + tagsByAI)\n- **Maximum 50 tags per category** per document\n- **Category must exist** and be active when adding structured tags\n- **Tag names within category must be unique** per document\n\n## Firestore Security Rules\n\n### Security Rules for v1.1\n```javascript\n// Evidence document access\nmatch /teams/{teamId}/evidence/{evidenceId} {\n  allow read, write: if \n    request.auth != null &&\n    resource.data.get('teamId', teamId) == teamId &&\n    isTeamMember(teamId);\n  \n  // Validate structured tags on write\n  allow update: if\n    validateStructuredTags(request.resource.data.get('tagsByHuman', [])) &&\n    validateStructuredTags(request.resource.data.get('tagsByAI', []));\n}\n\nfunction validateStructuredTags(tags) {\n  return tags.size() <= 100 &&\n    tags.hasAll(['categoryId', 'categoryName', 'tagId', 'tagName', 'color']);\n}\n```\n\n## Query Patterns\n\n### Search Across Tag Types\n```javascript\n// Client-side filtering for tag search\nconst searchTerm = 'invoice';\n\nevidence.filter(doc => {\n  // Search structured tags\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  return structuredTags.some(tag => \n    tag.tagName.toLowerCase().includes(searchTerm) ||\n    tag.categoryName.toLowerCase().includes(searchTerm)\n  );\n});\n```\n\n### Category-Based Filtering\n```javascript\n// Filter by specific category and tags\nconst categoryFilters = {\n  'cat-doc-type': ['Invoice', 'Statement'],\n  'cat-institution': ['Bank of America']\n};\n\nevidence.filter(doc => {\n  const structuredTags = [...(doc.tagsByHuman || []), ...(doc.tagsByAI || [])];\n  \n  return Object.entries(categoryFilters).every(([categoryId, selectedTags]) => {\n    return structuredTags.some(tag => \n      tag.categoryId === categoryId && \n      selectedTags.includes(tag.tagName)\n    );\n  });\n});\n```\n\n## Performance Considerations\n\n### Indexing Strategy\n```javascript\n// Composite indexes for efficient queries\n[\n  ['tagsByHuman.categoryId', 'updatedAt'],\n  ['tagsByHuman.tagName', 'updatedAt'],\n  ['tagsByAI.categoryId', 'confidence', 'updatedAt']\n]\n```\n\n### Denormalization Benefits\n- **Category names** stored in each tag for fast display\n- **Colors** stored in tags to avoid category lookups\n- **Tag counts** computed and stored for quick statistics\n\n### Memory Management\n- **Lazy loading** of tag details when needed\n- **Pagination** for documents with many tags\n- **Caching** of frequently accessed category data\n\n## Feature Flags\n\n### Structured Tags Feature Control\n```javascript\n// Feature flag for structured tags (default enabled for clean slate)\nconst USE_STRUCTURED_TAGS = process.env.VITE_ENABLE_STRUCTURED_TAGS !== 'false';\n\n// Tag display helper\nconst getDisplayTags = (evidence) => {\n  if (USE_STRUCTURED_TAGS && evidence.tagsByHuman?.length > 0) {\n    return evidence.tagsByHuman.map(tag => tag.tagName);\n  }\n  return []; // Clean slate - no fallback needed\n};\n```\n\n## Testing Requirements\n\n### Unit Tests\n- [ ] Structured tag validation\n- [ ] Migration utilities  \n- [ ] Search across mixed tag types\n- [ ] Category-based filtering\n\n### Integration Tests\n- [ ] Evidence creation with structured tags\n- [ ] Legacy tag preservation during updates\n- [ ] Migration from v1.0 to v1.1 format\n- [ ] Rollback to v1.0 compatibility\n\n### Performance Tests\n- [ ] Query performance with 1000+ documents\n- [ ] Tag assignment operations <500ms\n- [ ] Search response time <300ms with mixed tags\n- [ ] Memory usage with large tag datasets","structuredPatch":[{"oldStart":219,"oldLines":18,"newStart":219,"newLines":18,"lines":[" "," ### Unit Tests"," - [ ] Structured tag validation","-- [ ] Migration utilities  ","-- [ ] Search across mixed tag types","+- [ ] Tag creation and assignment","+- [ ] Search across structured tag types"," - [ ] Category-based filtering"," "," ### Integration Tests"," - [ ] Evidence creation with structured tags","-- [ ] Legacy tag preservation during updates","-- [ ] Migration from v1.0 to v1.1 format","-- [ ] Rollback to v1.0 compatibility","+- [ ] Tag assignment and updates","+- [ ] Category integration with tags","+- [ ] Tag deletion and cleanup"," "," ### Performance Tests"," - [ ] Query performance with 1000+ documents"," - [ ] Tag assignment operations <500ms","-- [ ] Search response time <300ms with mixed tags","+- [ ] Search response time <300ms"," - [ ] Memory usage with large tag datasets","\\ No newline at end of file"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"d4a8a8b8-89c1-4f95-b233-251f25a2dd43","isSidechain":false,"userType":"external","cwd":"C:\\Users\\Brahm\\Git\\Bookkeeper","sessionId":"a0877e14-e5ed-411e-a740-e5d953a8632a","version":"1.0.98","gitBranch":"2025-08-29-Builder-Organizer-Feature","message":{"id":"msg_01BsekWxZFR1rQ8ZYfqqUG2D","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"The evidence schema documentation has been updated to reflect the clean slate state. Key changes made:\n\n1. **Updated Overview**: Removed references to backward compatibility and migration concerns\n2. **Simplified Structure**: Removed legacy tag fields (`tags`, `legacyTags`, `migrationStatus`, `migratedAt`) \n3. **Clean Implementation**: Emphasized this is the initial implementation without migration\n4. **Removed Migration Strategy**: Replaced with simple implementation notes\n5. **Simplified Security Rules**: Removed legacy tag preservation logic\n6. **Updated Query Patterns**: Removed references to legacy tag searches\n7. **Replaced Rollback Plan**: With feature flag approach for clean implementation\n8. **Updated Testing**: Focused on new functionality rather than migration testing\n\nThe document now reflects a clean, structured tagging system implementation without the complexity of maintaining backward compatibility with non-existent legacy data."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":635,"cache_read_input_tokens":33253,"cache_creation":{"ephemeral_5m_input_tokens":635,"ephemeral_1h_input_tokens":0},"output_tokens":196,"service_tier":"standard"}},"requestId":"req_011CSfH7LpYrggu8FeN5Yf21","type":"assistant","uuid":"115aa859-5f13-4863-968f-2766076dbf15","timestamp":"2025-08-31T06:01:19.913Z"}
